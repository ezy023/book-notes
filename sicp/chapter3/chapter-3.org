* Chapter 3 Modularity, Objects, and State
- Focusing on two system organiation strategies
  - The first concentrates on /objects/, viewing the larger system as a collection of distinct objects whose behaviors may change over time.
  - The second concentrates on the streams of information that flow in the system.
** 3.1 Assignment and Local State
- An object is said to "have state" if its behavior is influenced by its history
- Each computational object must have its own /local stat variables/ describing the actual object's state.
*** 3.1.1 Local State Variables
- A new form, ~set!~ can be used to change a symbols value
#+BEGIN_SRC scheme
(set! <name> <new-value>)
#+END_SRC
  - ~set!~ changes ~<name>~ to the value of the result obtained by evaluating ~<new-value>~

#+BEGIN_SRC scheme
(begin <exp1> <exp2> ... <expK>)
#+END_SRC
- A new form ~begin~ evaluates the expressions passed to it in sequence and returns the value of the final expression, ~<expK>~ as the value of the entire ~begin~ form.
**** Exercises
***** 3.1
#+BEGIN_SRC scheme
(define (make-accumulator val)
  (lambda (amount)
    (begin (set! val (+ val amount))
           val)))
#+END_SRC
***** 3.2
#+BEGIN_SRC scheme
  (define (make-monitored f)
    (let ((count 0))
      (define (how-many-calls?)
        count)
      (define (reset-count)
        (set! count 0))
      (define (dispatch m)
        (cond ((eq? m 'how-many-calls?) (how-many-calls?))
              ((eq? m 'reset-count) (reset-count))
              (else
               (begin (set! count (+ count 1))
                      (f m)))))
      dispatch))

(define (my-display s) (display s))
(define p (make-monitored my-display))

(p "test")
(p 'how-many-calls?)
(p 'reset-count)
#+END_SRC
***** 3.3
#+BEGIN_SRC scheme
(define (make-account balance passwd)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch pw m)
    (if (eq? pw passwd)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              (else (error "Unknown request -- MAKE-ACCOUNT"
                           m)))
        (error "Incorrect password")))
  dispatch)

(define acc (make-account 100 'some-password))
((acc 'some-password 'withdraw) 40)
((acc 'some-other-password 'deposit) 50)
#+END_SRC
***** 3.4
#+BEGIN_SRC scheme
(define (make-account balance passwd)
  (let ((attempts 7))
    (define (withdraw amount)
     (if (>= balance amount)
         (begin (set! balance (- balance amount))
                balance)
         "Insufficient funds"))
   (define (deposit amount)
     (set! balance (+ balance amount))
     balance)
   (define (call-the-cops)
     (error "Too many invalid attempts, calling the cops"))
   (define (dispatch pw m)
     (if (eq? pw passwd)
         (cond ((eq? m 'withdraw) withdraw)
               ((eq? m 'deposit) deposit)
               (else (error "Unknown request -- MAKE-ACCOUNT"
                            m)))
         (begin
           (if (= attempts 0)
               (call-the-cops)
               (set! attempts (- attempts 1)))
           (error "Incorrect password"))))
   dispatch))

(define acc (make-account 100 'some-password))
((acc 'wrong-password 'withdraw) 90)
#+END_SRC
*** 3.1.2 The Benefits of Introducing Assignment
**** Exercises
***** 3.5
**Unfinished**
- Given in section
#+BEGIN_SRC scheme
(define (rand-update x)
  (modulo (+ 31 (* 29 x)) 11))
(define random-init 23)
(define my-rand
  (let ((x random-init))
    (lambda ()
      (set! x (rand-update x))
      x)))

(define (estimate-pi trials)
  (sqrt (/ 6 (monte-carlo trials cesaro-test))))
(define (cesaro-test)
  (= (gcd (my-rand) (my-rand)) 1))
(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (display trials-passed) (display " ") (display trials)
           (/ trials-passed trials))
          ((experiment)
           (iter (- trials-remaining 1) (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1) trials-passed))))
  (iter trials 0))
#+END_SRC
- Solution (Unfinished)
#+BEGIN_SRC scheme
(define (random-in-range low high)
  (let ((range (- high low)))
    (+ low (random range))))
(define (predicate x y r)
  (lambda (xg yg)
    (<= (square r)
        (+ (square (- xg x))
           (square (- yg y))))))
(define (area-of-square x1 x2 y1 y2)
  (* (- x2 x1)
     (- y2 y1)))
(define (estimate-integral P x1 x2 y1 y2 trials)
  (* (monte-carlo trials (lambda () (P (random-in-range x1 x2)
                                       (random-in-range y1 y2))))
     (area-of-square x1 x2 y1 y2)))
(estimate-integral (predicate 5 7 3) 2 8 4 10 1000)
#+END_SRC
***** 3.6
#+BEGIN_SRC scheme
(define my-rand
  (let ((initial random-init))
    (let ((x initial))
      (define (generate)
        (begin (set! x (rand-update x))
               x))
      (define (reset val)
        (set! x val))
      (define (dispatch m)
        (cond ((eq? m 'generate)
               (generate))
              ((eq? m 'reset)
               reset)
              (else
               (error "Unknown procedure -- MY-RAND"))))
      dispatch)))
#+END_SRC
*** 3.1.3 The Costs of Introducing Assignment
- Programming without any use of assignments is known as /functional programming/. Two evaluations of the same procedure with the same arguments will produce the same result.
- With the introduction of ~set!~ and the idea that the value of a variable can change, a variable can no longer be considered as simply a name for a value, but now is a symbole that refers to a place where a value can be stored, and the value stored at this place can change.
**** Sameness and change
- A language that supports the concept that "equals can be substituted for equals" in an expression without changing the value of the expression is said to be /referentially transparent/.
  - Referentials transparency is violated when we include ~set!~ in our computer languages.
**** Pitfalls of imperative programming
- Programming that makes extensive use of assignment is known as /imperative programming/
- In general, programming with assignment forces us to carefully consider the relative orders of the assignments to make sure that each statement is using the correct version of the variables that have been changed.
**** Exercises
***** 3.7
#+BEGIN_SRC scheme
(define (make-account balance passwd)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch pw m)
    (if (eq? pw passwd)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              (else (error "Unknown request -- MAKE-ACCOUNT"
                           m)))
        (error "Incorrect password -- MAKE-ACCOUNT" (list pw))))
  dispatch)

(define (make-joint account password new-password)
  (define (dispatch pw m)
    (if (eq? pw new-password)
        (account password m)
        (error "Incorrect password -- MAKE-JOINT" pw)))
  dispatch)

(define peter-acc (make-account 100 'open-sesame))
(define paul-acc (make-joint peter-acc 'open-sesame 'rosebud))

((peter-acc 'open-sesame 'deposit) 100)
((paul-acc 'rosebud 'withdraw) 150)
((paul-acc 'rosebud 'deposit) 200)
#+END_SRC
***** 3.8
Skipped
** 3.2 The Environment Model of Evaluation
- Variables designate a place in which values can be stored. These places are maintained in structures called /environments/
  - An environment is a sequence of /frames/, each frame being a table (possibly empty) of /bindings/ that associate variable names with their corresponding values
    - A single frame may contain at most one binding for any variable
    - Each frame also contains a pointer to its /enclosing environment/ unless it is the /global/ frame
  - The value of a variable with respect to an environment is the value given by the binding of the variable in the first frame in the environment that contains a binding for that variable.
  - If no frame in the sequence specifies a binding for the variable then the variable is said to be /unbound/ in the environment.
- The environment is crucial to the evaluation process because it determines the context in which an expression should be evaluated
- One could say that expressions in a programming language do not, in themselves, have any meaning. Rather an expression acquires a meaning only with respect to some environment in which it is evaluated.
*** 3.2.1 The Rules for Evaluation
- The environment model of procedure application can be summarized by two rules:
.  - A procedure object is applied to a set of arguments by constructing a frame, binding the formal parameters of the procedure to the arguments of the call, and then evaluating the body of the procedure in the context of the new environment constructed. The new frame has as its enclosing environment the environment part of the procedure object being applied
  - A procedure is created by evaluating a ~lambda~ expression relative to a given environment. The resulting procedure object is a pair consisting of the text of the ~lambda~ expression and a pointer to the environment in which the procedure was created.

- Defining a symbol using ~define~ creates a binding in the current environment frame and assigns to the symbol the indicated value.
- Evaluating the ~set!~ expression in some environment locates the binding of the variable in the environment and changes the binding to indicate the new value
  - If the variable is unbound in the environment ~set!~ signals an error
*** 3.2.2 Applying Simple Procedures
**** Exercises
***** 3.9
#+BEGIN_SRC artist

#+END_SRC
Skipped (done on paper)
*** 3.2.3 Frames as the Repository of Local State
**** Exercises
***** 3.10
(on paper)
The difference between the two environment structures is that ~W1~ contains a third frame which holds the definition of the ~amount~ variable in the ~lambda~ that is provided in the ~(W1 50)~ call.
*** 3.2.4 Internal Definitions
The environment model explains the two key properties that make local procedure definitions a usefult technique for modularizing programs
- Local procedure names do not interfere with names external to the enclosing procedure because the local procedure names will be bound in the frame that the procedure creates when it is run, rather than being bound in the global environment
- The local procedure can access arguments of the enclosing procedure, simply by using parameter names as free variables. This is because the body of the local procedure is evaluated in an environment that is subordinate to the evaluation environment of the enclosing procedure.
**** Exercises
***** 3.11
The local state for ~acc~ is kept in the environment frame, E1, that is created by the call to ~make-account~.

With a second account, ~acc2~, created by the call to ~make-account~, a new environment frame is created and holds the state of ~acc2~'s balance. The environment structures that are shared betwee the two are the procedure definitions for ~withdraw~, ~deposit~, ~dispatch~
** 3.3 Modeling with Mutable Data
- /mutators/ are operation that modify data objects
  - Data objects for which mutators are defined are known as /mutable data objects/
*** 3.3.1 Mutable List Structure
***** Exercises
****** 3.12
#+BEGIN_SRC scheme
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))

(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append! x y))
#+END_SRC
Since ~append!~ is a mutable operation, changing the ~x~ structure, the results of ~(append! x y)~ means that the last pair in ~x~ has its ~cdr~ pointer set to point to ~y~. Therefore ~x~ is now the full list ~(a b c d)~ -- no new list was created as happens with the normal ~append~ procedure that appends by cons'ing elements of x onto y -- and y still represents the list ~(c d)~

#+BEGIN_SRC scheme
(cdr x)
; '(b c d)
(define w (append! x y))

(cdr x)
; '(b c d)
#+END_SRC

The result of ~(cdr x)~ is the same for each operation above because ~append!~ sets the cdr pointer for x rather than building a new list. Thus when we call ~(append! x y~ again for the definition of ~w~ we are just resetting the cdr pointer of ~x~ to ~y~, which it is already at from the definition of ~z~ above.
****** 3.13
#+BEGIN_SRC scheme
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
(define z (make-cycle (list 'a 'b 'c)))
#+END_SRC
~z~ becomes a list in which the last pair, ~c~, has as its cdr a pointer to the first pair ~a~. If you try to compute the ~(last-pair z)~ you would enter an infinite loop because the list of z never terminates and you would not ever reach the base case of having a null ~cdr~ cell.
****** 3.14
#+BEGIN_SRC scheme
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))

(define v (list 'a 'b 'c 'd))
(define w (mystery v))
#+END_SRC

The ~mystery~ procedure reverses the input list. The value of ~v~ however, becomes a single value list because on the initial execution of the procedure the ~set-cdr!~ procedure is passed a pointer to ~v~ and sets the ~cdr~ of ~v~ to the empty list. In the proceeding calls to loop it is passed the ~cdr~ of the list that is pointed to by the ~temp~ variable. So, at the end of the procedure ~w~ points to the first cell in the list, ~d~, while ~v~ contains a pointer to the last cell in the list, ~a~.
#+BEGIN_SRC
w                        v
[d][-]->[c][-]->[b][-]->[a][/]
#+END_SRC
**** Sharing and identity
***** Exercises
****** 3.15
<On paper>
****** 3.16
<On paper>
****** 3.17
#+BEGIN_SRC scheme
(define (count-pairs x)
  (let ((seen '()))
    (define (count y)
      (cond ((not (pair? y)) 0)
            ((memq y seen) 0)
            (else
             (set! seen (cons y seen))
             (+ (count (car y))
                (count (cdr y))
                1))))
    (count x)))




(define z1 '(a b c))
(count-pairs z1)

(define z2 '((a b) c d))
(count-pairs z2)

(define z3 '((a b) (c d)))
(count-pairs z3)

(define z4 (cons (cons 'a 'b) (cons 'c 'd)))
(count-pairs z4)

(define z5 (cons (cons (cons 'a 'b) 'c)
                 (cons 'd 'e)))
(count-pairs z5)
#+END_SRC
Used help from the sicp community wiki and other solutions
****** 3.18
#+BEGIN_SRC scheme
(define (cycle? l)
  (define (check-cdrs f s)
    (cond ((null? s) #f)
          ((null? f) #f)
          ((eq? (car f) (car s))
           #t)
          (else
           (if (null? (cdr s))
               #f
               (check-cdrs (cdr f) (cddr s))))))
  (check-cdrs (cdr l) (cddr l)))

(cycle? (list 'a 'b 'c 'd 'e))
(cycle? (circular-list 'a 'b 'c 'd 'e))
#+END_SRC
The above procedure works by looping through the list at two different rates, one looping through one element at a time using ~cdr~, the other looping through two elements at a time using ~cddr~. If the list is a cycle, eventually the faster loop using ~cddr~ will loop around the list and the ~car~ of the sublists created by ~cdr~ and ~cddr~ will be the same and we'll reach the determination the list is cyclical. If either results in a null value, we know the list terminates without a cycle present.
****** 3.19
The above algorithm for Exercise 3.18 works in constant space because it iterates over the same list at different rates. Essentially it just moves two pointer over the list at different rates until the list terminates or the pointers point to the same item. No additional space is needed. The solution is essentially Floyd's tortoise and hare algorithm.
**** Mutation is just assignment
The same way we can represent compound data in terms of procedures we can also represent mutable data objects as procedures using assingment and local state
#+BEGIN_SRC scheme
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else
           (error "Undefined operation -- CONS" m))))
  dispatch)
#+END_SRC
*** 3.3.2 Representing Queues
- A /queue/ is a sequence in which items are inserted at one end (the /rear/ of the queue) and deleted from the other end (the /front/)
  - Items are always removed in the order they are inserted, thus a queue is sometimes called a /FIFO/ (first in, first out) buffer
**** Exercises
***** 3.21
The queue is represented as pointers to places on a list. When ~b~ is deleted the from the queue it still appears to be in the queue because the ~rear-ptr~ of the queue is still pointing to that pair event though the ~front-ptr~ is pointing to the empty list (which is the ~cdr~ of the last item of the list). In the ~delete-queue!~ procedure, we only update the front-pointer however.
What is meant by the LISP printer not understanding the queue representation, the printer is interpreting the queue as two pointers to list objects. The front pointer points to the first item which is the beginning of the list representation and when the printer encounters the pair which the front pointer points to, it prints it as a list until it reaches a pair with a ~cons~ cell of the empty list signaling the termination of the list. When the the printer inspects the rear pointer of the queue it just see a single pair in which the ~car~ cell is the value and the ~cons~ cell is the empty list, so it prints it as the last item of a list. The following snippet illustrates this in code:
#+BEGIN_SRC scheme
(define the-list '(a b c d))
;; front-ptr
(define front the-list)
;; rear-ptr
(define rear (cdddr l))
;; queue represented as a pair
(display (cons l rear))
#+END_SRC

~print-queue~ below prints the sequence of items in the queue, rather than the pair that reprsents the points to the front and rear of the queue.
#+BEGIN_SRC scheme
(define (print-queue queue)
  (display (front-ptr queue)))

(define q1 (make-queue))
(insert-queue! q1 'a)
(insert-queue! q1 'b)
(insert-queue! q1 'c)
(display q1)
(print-queue q1)
(delete-queue! q1)
(display q1)
(print-queue q1)
#+END_SRC
***** 3.22
#+BEGIN_SRC scheme
(define (new-make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty-queue?)
      (null? front-ptr))
    (define (insert-queue! item)
      (let ((new-entry (cons item '())))
        (if (empty-queue?)
            (begin
              (set! front-ptr new-entry)
              (set! rear-ptr new-entry)
              front-ptr)
            (begin
              (set-cdr! rear-ptr new-entry)
              (set! rear-ptr new-entry)
              front-ptr))))
    (define (delete-queue!)
      (if (empty-queue?)
          (error "DELETE called with an empty queue")
          (begin
            (set! front-ptr (cdr front-ptr))
            front-ptr)))
    (define (print-queue)
      (display front-ptr)
      (newline)
      (display rear-ptr)
      (newline)
      (display (cons front-ptr rear-ptr)))
    (define (dispatch m)
      (cond ((eq? m 'empty-queue?) empty-queue?)
            ((eq? m 'insert-queue!) insert-queue!)
            ((eq? m 'delete-queue!) delete-queue!)
            ((eq? m 'print-queue) print-queue)
            (else (error "No method defined for queue -- DISPATCH " m))))
    dispatch))

(define q2 (new-make-queue))
((q2 'print-queue))
((q2 'insert-queue!) 'a)
((q2 'insert-queue!) 'b)
((q2 'insert-queue!) 'c)
((q2 'delete-queue!))
#+END_SRC
***** 3.23
#+BEGIN_SRC scheme
;; Deque

;;; Deque Entry
(define (make-deque-entry val)
  ;; entry is a pair of (val, prev-pointer)
  (cons val '()))
(define (deque-entry-prev entry)
  (cdr entry))
(define (deque-entry-value entry)
  (car entry))
(define (set-deque-entry-prev! entry v)
  (set-cdr! entry v))

;;; Deque impl
(define (make-deque)
  (cons '() '()))
(define (front-deque d)
  (car d))
(define (rear-deque d)
  (cdr d))
(define (set-front-deque! d v)
  (set-car! d v))
(define (set-rear-deque! d v)
  (set-cdr! d v))
(define (empty-deque? d)
  (and (null? (front-deque d))
       (null? (rear-deque d))))
(define (deque-pair-entry pair)
  (car pair))
(define (front-insert-deque! d item)
  (let ((new-entry (make-deque-entry item))
        (head (front-deque d)))
    (let ((new-pair (cons new-entry '())))
      (set-deque-entry-prev! (deque-pair-entry head) new-entry)
      ;; could (cons new-entry head) instead of set-cdr! here
      (set-cdr! new-pair head)
      (set-front-deque! d new-pair))))
(define (rear-insert-deque! d item)
  (let ((new-entry (make-deque-entry item)))
    (let ((new-pair (cons new-entry '())))
      (if (empty-deque? d)
         (begin
           (set-front-deque! d new-pair)
           (set-rear-deque! d new-pair))
         (begin
           (let ((tail (rear-deque d)))
             (set-deque-entry-prev! new-entry tail)
             (set-cdr! tail new-pair)
             (set-rear-deque! d new-pair)))))))
(define (front-delete-deque! d)
  (set-front-deque! d (cdr (front-deque d))))
(define (rear-delete-deque! d)
  (let ((tail (rear-deque d)))
    (let ((tail-prev (deque-entry-prev (deque-pair-entry tail))))
      (set-cdr! tail-prev '())
      (set-rear-deque! d tail-prev))))
(define (print-deque d)
  (map deque-entry-value (front-deque d)))


(define d1 (make-deque))
(rear-insert-deque! d1 'a)  ; (a)
(rear-insert-deque! d1 'b)  ; (a b)
(front-insert-deque! d1 'c) ; (c a b)
(rear-delete-deque! d1)     ; (c a)
(front-delete-deque! d1)    ; (a)

(print-deque d1)
#+END_SRC
*** 3.3.3 Representing Tables
#+BEGIN_SRC scheme
(define (lookup key table)
  ;; (cdr table) because the table is represented by a 'headed list' and the first record is the dummy record
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))

(define (assoc key records)
  (cond ((null? records) false)
        ;; a record is a pair with the car cell pointing to a pair of (key . val) and the cdr cell pointing to the next record
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))

(define (insert! key value table)
  ;; again, (cdr table) because the first record is the dummy record
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value) (cdr table))))))

(defin (make-table)
  (list '*table*))
#+END_SRC
**** Two dimensional tables
#+BEGIN_SRC scheme
(define (lookup key-1 key-2 table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))

(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table))))))
#+END_SRC
**** Creating local tables
Below implements a table as a procedure that keeps an internal table as part of its local state.
#+BEGIN_SRC scheme
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                 (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))
#+END_SRC
**** Exercises
***** 3.24
#+BEGIN_SRC scheme
(define (make-table->same-key same-key?)
  (let ((local-table (list '*table*)))
    (define (lookup key)
      (let ((record (same-key? key (cdr local-table))))
        (if record
            (cdr record)
            false)))
    (define (insert! key value)
      (let ((record (same-key? key (cdr local-table))))
        (if record
            (set-cdr! record value)
            (set-cdr! local-table
                      (cons (cons key value)
                            (cdr local-table))))))
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))

(define t1 (make-table->same-key assoc))
((t1 'lookup-proc) "first")
((t1 'insert-proc!) "first" 1)
((t1 'insert-proc!) "second" 2)
((t1 'lookup-proc) "first")
((t1 'lookup-proc) "second")

(define (assoc-round key table)
  (if (null? table)
      false
      (let ((record (car table)))
        (if (= (round key) (round (car record)))
            record
            (assoc-round key (cdr table))))))
(define t2 (make-table->same-key assoc-round))
((t2 'lookup-proc) 1.2)
((t2 'insert-proc!) 1.2 "first")
((t2 'lookup-proc) 1.3)
((t2 'insert-proc!) 2.4 "second")
((t2 'lookup-proc) 1.9)
#+END_SRC
***** 3.25
#+BEGIN_SRC scheme
(define (make-table->general)
  (let ((local-table (list '*table*)))
    (define (lookup keys)
      (define (internal-lookup keys table)
        (let ((key (car keys)))
          (let ((record (assoc key (cdr table))))
            (if record
                (if (not (null? (cdr keys)))
                    (internal-lookup (cdr keys) record)
                    (cdr record))
                false))))
      (internal-lookup keys local-table))
    (define (insert! keys val)
      (define (internal-insert keys val table)
       (let ((key (car keys)))
         (if (null? (cdr keys))
             ;; last key, create a record
             (let ((record (assoc key (cdr table))))
               (if record
                   (set-cdr! record val)
                   (set-cdr! table (cons (cons key val)
                                         (cdr table)))))
             ;; more keys left, looking at subtables
             (let ((record (assoc key (cdr table))))
               (if record
                   ;; i already have a subtable or record here, cdr could be a pair or val, if its a val it needs to become a pair
                   (if (pair? (cdr record))
                       ;; record is a list already
                       (internal-insert (cdr keys) val record)
                       ;; else i have a k-v and need to create a new subtable
                       (let ((subtable (list key)))
                         (internal-insert (cdr keys) val subtable)
                         (set-cdr! record (cdr subtable))))
                   ;; no record here, new subtable
                   (let ((subtable (list key)))
                     (internal-insert (cdr keys) val subtable)
                     (set-cdr! table (cons subtable
                                           (cdr table)))))))))
      (internal-insert keys val local-table))
    (define (show)
      (display local-table))
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            ((eq? m 'show) show)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))

(define t4 (make-table->general))
((t4 'lookup-proc) (list 'one))
((t4 'insert-proc!) (list 'one) 1)
((t4 'insert-proc!) (list 'one 'two) 2)
((t4 'lookup-proc) (list 'one 'two))
((t4 'insert-proc!) (list 'one 'three) 3)
((t4 'lookup-proc) (list 'one 'three))
((t4 'insert-proc!)  (list 'one 'two 'four) 4)
((t4 'lookup-proc) (list 'one 'two 'four))
((t4 'show))
((t4 'insert-proc!) (list 'one 'three 'five 'six) 6)
((t4 'lookup-proc) (list 'one 'three 'five 'six))
#+END_SRC
***** 3.26
A table with entries, key-value pairs, organinzed using a binary tree would allow for me efficient lookups and insertions into the table. Moving from an list-structure with O(n) operation to a tree with O(log n) operation would be a significant improvement. To implement a table backed by a binary tree you would need a means to sort the keys, for example with string keys you may sort them alphabetically. With this in place inserts of new records would be the same as inserting into a new tree: start at the root node, compare the key, walk down the left branch if the key is less than, walk down the right if the key is greater than, when you reach an empty branch insert the record. Lookups then follow the same pattern of walking the tree, returning the record if the key is found or false if it is not. To support subtables the implementation remains similar to the list implementation above, but when inserting a subtable at a key instead of creating a new headed list we create a new tree and set the value pointer of the key in the primary table to the pointer of the new root node of the tree. Lookups into subtable would proceed similarly, look up the first key, if the value of the first key is a tree then look up the second key in the subtable tree and proceed until you find the value or false.
***** 3.27
(Diagram drawn on paper)
~memo-fib~ computes the n-th fibonacci number in a number of steps proportional to n because it only needs to compute each fibonacci number once, then the number is memoized in the table. Therefore to compute ~(memo-fib 3)~ you only ever need to compute at most 3 fibonacci number, the first comput for each number in the sequence up to three. After that the computation is stored and can be retrieved from the table instead of being recomputed on a future execution of the procedure. So, for example, after you have incurred the cost of calculated the first 3 fibonacci numbers, if you execute the procedure for the next in sequence, ~(memo-fib 4)~, instead of computing ~(+ (memo-fib 2) (memo-fib 3))~ you just lookup the previously computed values, add them and return, so the calculation has only take one addition step, that for the 4th fibonacci number, instead of the four steps needed to calculate the 4th fibonacci number from scratch. So as you calculate number further along in the sequence the number of steps will grow proportionally to n, but not exponentially as it would in an un-memoized version. ~(memo-fib 5)~ takes one additional step on top of ~(memo-fib 4)~, ~(memo-fib 6)~ one more on top of 5 and so on.
*** 3.3.4 A Simulator for Digital Ciruits
- /event-driven simulation/ - actions ("events") trigger further events that happen at a later time, which in turn trigger more events, and so on.
- A /half-adder/ circuit consists of an or-gate, two and-gates, and an inverter. It takes two input signals, A and B, and produces two output signals, S and C. S will be 1 whenever precisely one of A and B is 1, and C will be 1 whenever A and B are both 1.
- A /full-adder/ is composed of two half-adders and an or-gate. It is the basic circuit element used in adding two binary numbers.

- **Quote** "In a language in which we can deal with procedures as objects, there is no fundamental difference between "procedures" and "data", we can choose our syntatic sugar to allow us to program in whatever style we choose."
  - from footnote 27 in "Representing wires"
**** Exercises
***** 3.28
#+BEGIN_SRC scheme
(define (logical-or s1 s2)
  (or (= s1 1) (= s2 1)))

(define (or-gate a1 a2 output)
  (define (or-action-procedure)
    (let ((new-value
           (logical-or (get-signal a1) (get-signal a2))))
      (after-dealy or-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)
#+END_SRC
***** 3.29
#+BEGIN_SRC scheme
(define (or-gate->and-gates-and-inverters a1 a2 output)
  (define (or-action-procedure)
    (let ((c (make-wire))
          (d (make-wire))
          (e (make-wire)))
      (inverter a1 c)
      (inverter a2 d)
      (and-gate c d e)
      (inverter e output)))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure))
#+END_SRC
The delay time for the above or-gate would at most be the combined delays of the function boxes, which are three inverters and an and-gate. So the delay or the or-gate is equal to ~(3 * inverter_delay) + and-delay~. Depending on if the initial input signals are set simultaneously the first inverter delay could happen at the same time which would result in a lower bound delay time of ~(2 * inverter_delay) + and-delay~.
***** 3.30
#+BEGIN_SRC scheme
(define (ripple-carry-adder a-wires b-wires s-wires cin)
  (let (cout (make-wire))
    (if (null? a-wires)
        'ok
        (let ((fa (full-adder (car a-wires)
                              (car b-wires)
                              cin
                              (car s-wires)
                              cout)))
          (ripple-carry-adder (cdr a-wires)
                              (cdr b-wires)
                              (cdr s-wires)
                              cout)))))
#+END_SRC
The delay needed to obtain the complete result from an n-bit ripple-carry-adder would the the combined delay of n full-adders since each high-order bit adder needs to wait for the completion of the lower-order bit adder to provide the carry input signal. The delay of a full adder is two half-adders and an or-gate. The delay of a half-adder is two and-gates, one inverter and one or-gate. So the full delay in terms of gates and inverters would be:
#+BEGIN_SRC
delay = n * full-adder-delay
full-adder-delay = (2 * half-adder-delay) + or-gate-delay
half-adder-delay = (2 * and-gate-delay) + inverter-delay + or-gate-delay
delay = n * (2 * ((2 * and-gate-delay) + inverter-delay + or-gate-delay) + or-gate-delay
#+END_SRC
***** 3.31
We have to execute the procedure in ~accept-action-procedure!~ because if we do not we'll introduce extra delays into the system. When a procedure is added it can change the signal on the output wire which can then impact circuits downstream. If we do not execute this change immediately when the procedure is added we can end up with delayed processing times, or worse wrong data because the new state of the circuit will not have been fully updated the next time a procedure is run by ~the-agenda~.
***** 3.32
The procedures kept in a time segment queue have to be FIFO in order to preserve the proper event ordering and propagation through the circuit. If the procedures were executed as an ordinary list then events would not be executed in the proper order and the wrong signal would be sent on the output wires because the input signals would be carrying the wrong input. The expected inputs would be wrong because events would not be executed in the proper order.
*** 3.3.5 Propagation of Constraints
**** Exercises
***** 3.33
#+BEGIN_SRC scheme
(define (averager a b c)
  (let ((sum (make-connector))
        (num-args (make-connector)))
    (constant 2 num-args)
    (adder a b sum)
    (multiplier num-args c sum)))

(define arg1 (make-connector))
(define arg2 (make-connector))
(define result (make-connector))
(constant 3 arg1)
(constant 5 arg2)
(averager arg1 arg2 result)
(has-value? result)
(get-value result)
#+END_SRC
***** 3.34
Defining a ~squarer~ as:
#+BEGIN_SRC scheme
(define (squarer a b)
  (multiplier a a b))
#+END_SRC
I flawed because the same connector, ~a~, being used for both terminals on ~squarer~ constraint will result in the constraint failing to work because it will be unable to process a new value since none of the condition statements will execute, unless the value is set from an outside informant. If the value is set from an outside informant though it will never be unset in ~process-forget-value~ within the constraint device because the informant in the constraint device will be the device and not the outside user who initially set the value on the connector. Thus, the ~squarer~ constraint device can be used at most one time.z
***** 3.35
#+BEGIN_SRC scheme
(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "square less than 0 -- SQUARER" (get-value b))
            (set-value! a (sqrt (get-value b)) me))
        (if (has-value? a)
            (let ((a-val (get-value a)))
              (set-value! b
                          (* a-val a-val)
                          me)))))
  (define (process-forget-value)
    (forget-value! a me)
    (forget-value! b me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- SQUARER" request))))
  (connect a me)
  (connect b me)
  me)

(define arg (make-connector))
(define result (make-connector))
(constant 3 arg)
(squarer arg result)
(has-value? result)
(get-value result)
#+END_SRC
***** 3.36
On paper
***** 3.37
#+BEGIN_SRC scheme
(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))

(define C (make-connector))
(define F (celsius-fahrenheit-converter C))

(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))

(define (c- x y)
  (let ((z (make-connector)))
    (adder z y x)
    z))
(define (c* x y)
  (let ((z (make-connector)))
    (multiplier x y z)
    z))
(define (c/ x y)
  (let ((z (make-connector)))
    (multiplier z y x)
    z))
(define (cv x)
  (let ((z (make-connector)))
    (constant x z)
    z))
#+END_SRC
** 3.4 Concurrency: Time is of the Essence
- The central issue lurking beneath the complexity of state, sameness, and change is that by introducing assignment we are forced to admit /time/ into our computational models.
  - Before introducing assignment our programs were timeless, in the sense that any expression that has a value always has the same value
- Even if the programs are to be executed on a sequential computer, the practice of writing programs as if they were to be executed concurrently forces the programmer to avoid inessential timing constraints and thus makes programs more modular.
*** 3.4.1 The Nature of Time in Concurrent Systems
- "Time is a device that was invented to keep everything from happening at once"
- With concurrent processes we must be especially careful about assignments, because we may not be able to control the order of the assignments made by the different processes.
**** Exercises
***** 3.38
a.
100 + 10 - 20 - 45* = 45
100 - 50* - 20 + 10 = 40
100 - 20 - 40* + 10 = 50
100 + 10 - 55* - 20 = 35
- * denotes withdrawal of half the account
b.
Other values that could occur if the processes were interleaved would be:
- 90, if the two withdrawals happen concurrently the balance could be set to 80 and "erase" the withdrawal of half the account, then the 10 deposit would increase to 90
- 110 if the processes happen concurrently all reading the initial balance and the last ~set!~ to be executed is that of the deposit ~(set balance (+ initial-balance 10))~
- Other values could be any combination of 1 or more of the transactions since we do not know how the processes are interleaved and which reads or writes could potentially be executed and written back to the balance.
*** 3.4.2 Mechanisms for Controlling Concurrency
- A more practical approach to the design of concurrent systems is to devise general  mechanisms that allow us to constrain the interleaving of concurrent processes so that we can be sure that the program behavior is correct.
- One approach is /serialization/
  - Serialization implements the following idea: Processes will execute concurently, but there will be certain colletions of procedures that cannot be executed concurrently.
    - serialization creates distinguished sets of procedures such that only one execution of a procedure in each serialized set is permitted to happen at a time. If some procedure in the set is being executed, then a process that attempts to execute any procedure in the set will be forced to wait until the first execution has finished.
***** Exercises
****** 3.39
 100: P1 reads x as 10, P2 reads, increments and sets x as 11, P1 sets x as 100
 101: P1 reads x as 10, sets as 100, then P2 increments
 121: P2 reads x as 10, increments and sets x to 11, then P1 reads and sets to 121
****** 3.40
 100: P1 process reads 10 and sets 100 over the execution of P2
 1000: the inverse of the above, P2 sets over P1
 1,000,000: serial execution
 10,000; 100,000: various intertwining reads and sets of x
****** 3.41
 I do not agree, reading the balance is an atomic procedure, it just returns the value at a point in time, and since the procedures ~withdraw~ and ~deposit~ are serialized, their access of the ~balance~ variable within the procedures are serialized as well. Since both procedures that modify the state of the ~balance~ variable are "protected" by the same serializer there is no need to serialize the read of ~balance~.
****** 3.42
 It should be a safe change to make, the procedures are still serialized, what is being lost is the creation of new serialized procedure for each call, but since the procedures can be expected to operation atomically on the balance due to the serialization of the execution, there should be no difference in behavior.
****** 3.43
 If run sequentially, the exchange procedures will preserve the total values in the accounts because the sequentially execution will guarantee that only two account values are exchanged at any time. So all the values can do is "change places" between accounts, but the values themselves should never change. If the exchange procedures are executed without the protection of a serializer, the values in the accounts may chage, but the combinined total will remain the same. This is due to the interleaving of process executions on the balances of the accounts. Two concurrent processes may both look to remove $10 from account a1 and deposit it into a2 and a3 which could result in account values of $0, $20, and $40, the account values have not been properly exchanged but the combined total in the accounts remains $60.
****** 3.44
 It looks to me like the biggest difference between the ~exchange~ and ~transfer~ procedures are the reads on the respective account balances that take place in the ~exchange~ procedure in order to determine the ~difference~ to be applied to each account. In the transfer procedure an amount that is assumed to be valid is take from the ~from-account~ and added to the ~to-account~, each of these procedures is serialized within the account. In the ~exchange~ procedure we first read the balances of the accounts to compute the amount to change each account by, which adds an addition set of instructions that could be erroneously interleaved if they are not serialized, resulting in the wrong values in each account at the end of the procedure.
****** 3.45
 When ~serialized-exchange~ is called the serializers in each account are also used for the withdraw and deposit procedures in ~exchange~ which, in addition to the serializers being used in the ~serialized-exchange~ procedure can lead to a deadlock situation between account serializers in which neither can proceed forward with the exchange due to the serializers being stuck in a loop of serial executions, each waiting for the procedure ahead of it to execute.
**** Implementing serializers
- A /mutex/ is an object that supports two operations -- the mutex can be /acquired/ and the mutex can be /released/.
  - Once a mutex has been acquired no other operations on that mutex may proceed until the mutex is released.
  - **Note** In most time-shared operating systems, processes that are blocked by a mutex do not waste time "busy waiting". Instead the system schedules another process to run while the first is waiting, and the blocked process is awakened when the mutex becomes available.
#+BEGIN_SRC scheme
(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))

(define (make-mutex)
  (let ((cell (list false)))
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire))) ; retry
            ((eq m 'release) (clear! cell))))
    the-mutex))
(define (clear! cell)
  (set-car!  cell false))

;; this 'test-and-set!' is not sufficient as we need to guarantee it is performed atomically
(define (test-and-set! cell)
  (if (car cell)
      true
      (begin (set-car! cell true)
             false)))

;; An atomic implementation in MIT Scheme
(define (test-and-set! cell)
  (without-interrupts
   (lambda ()
     (if (car cell)
         true
         (begin (set-car! cell true)
                false)))))
#+END_SRC
***** Exercises
****** 3.46
Foregoing drawing a timing diagram, if we do not have an atomic ~test-and-set!~ procedure then two processees could both acquire the mutex at the same time due to the interleaving of their instructions. If we have two processes, P1 and P2, each attempting to acquire the lock we end up with three instructions for each ~test-and-set!~ attempt: read the mutex state, test the mutex state, and set the mutex state if the test succeeds. These three instructions for each process can be interleaved, one example would look like: P1 and P2 both attempt to acquire the mutex, first they both read the mutex and see that it is available (or ~false~) and both processes then acquire the mutex (because both processes ~(set-car! cell true)~ to acquire the lock) and both processes then proceed to execute as if they were the exclusive owners of the mutex.
The fact that there are multiple instructions required to acquire the mutex and that the acquisition procedure is not atomic leads to many scenarios where multiple processes could all acquire the same mutex.
****** 3.47
******* a
#+BEGIN_SRC scheme
(define (make-semaphore n)
  (let ((count n)
        (mutex (make-mutex)))
    (define (the-semaphore m)
      (cond ((eq? m 'acquire)
             (mutex 'acquire)
             (if (> count 0)
                 (begin
                   (set! count (- count 1))
                   (mutex 'release))
                 (begin
                   (mutex 'release)
                   ; this is a busy wait and in a single threaded environment will infinitely loop
                   (the-semaphore 'acquire))))
            ((eq? m 'release)
             (mutex 'acquire)
             (set! count (- count 1))
             (mutex 'release))))
    the-semaphore))
#+END_SRC
******* b
#+BEGIN_SRC scheme
(define (make-semaphore n)
  (let ((count n)
        (cell (list false)))
    (define (the-semaphore m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell) ; acquire the lock
                 (the-semaphore 'acquire)
                 (if (> count 0)
                     (begin
                       (set! count (- count 1))
                       (clear! cell))
                     (the-semaphore 'acquire))))
            ((eq? m 'release)
             (if (test-and-set! cell)
                 (the-semaphore 'release)
                 (begin
                   (set! count (+ count 1))
                   (clear! cell))))))
    the-semaphore))
#+END_SRC
****** 3.48
Using numbered resources and having each process attempt to acquire the smallest numbered resource avoid deadlock because each process will see the same smallest numbered resource and attempt to acquire the lock on that resource, resulting in just one process being able to successfully acquire it and continue execution while the other have to wait for the resource lock to be released to continue. Thus, each process will try to acquire the same lock instead of two processes each trying successfully to acquire different locks on which the other depends, leading to deadlock.
****** 3.49
The above deadlock-avoidance mechanism may not work in a database where two processes are trying to acquire a write-lock on a set of rows in a table. If two processes are trying to modify rows that the other process is also trying to modify, perhaps through an index, the two processes could be deadlocked. Each process may only know of other rows it needs to update (through an index) once it acquires the write lock on the initial set of rows, and if the sets of rows the process learns it needs to update are held in a lock by the other process both processes may be unable to proceed.
** 3.5 Streams
*** 3.5.1 Streams Are Delayed Lists
- When we represent manipulations on sequences as trnasformations of lists, our programs must construct and copy data structures at every step of a process.
- Streams are a clever idea that allows one to use sequence manipulations without incurring the costs of manipulating sequences as lists.
- As a data abstraction streams are the same as lists. The difference is the time at which the elements are evaluated.
- Our implementation of streams relies on a couple special forms
  - ~delay~
    - ~(delay <exp>)~ does not evaluate the expression but returns a /delayed object/ which we can think of as a promise to evaluate ~<exp>~ at some future time.
    - ~delay~ is a special form in which ~(delay <exp>)~ can be thought of as syntactic sugar for ~(lambda () <exp>)~, which can then be evaluated later by ~force~.
    - This basic form can be optimized so that multiple invocations of ~force~ on a delayed object do not re-evaluate the procedure. To do this we can create a memoized version of the ~delay~ procedure.
      #+BEGIN_SRC scheme
      (define (memo-proc proc)
        (let ((already-run? false) (result false))
          (lambda ()
            (if (not already-run?)
                (begin (set! result (proc))
                       (set! already-run? true)
                       result)
                result))))
      #+END_SRC
      - ~delay~ can now be defined so that ~(delay <exp>)~ is equivalent to ~(memo-proc (lambda () <exp>))~
  - ~force~
    - ~force~ takes a delayed object as an argument and performs the evaluation, forcing ~delay~ to fulfill its promise
    - ~force can be implemented as a procedure that simply calls the no argument procedure produced by delay
      #+BEGIN_SRC scheme
      (define (force delayed-object)
        (delayed-object))
      #+END_SRC

- ~(cons-stream <a> <b>)~ is equivalent to ~(cons <a> (delay <b>))~
- Delayed evaluation can be thought of as "demand driven" programming whereby each stage in the stream processs is activated only enough to satisfy the next stage.
**** Exercises
***** 3.50
#+BEGIN_SRC scheme
(define (stream-map proc . argstreams)
  (if (stream-null? (car argstreams))
      the-empty-stream
      (cons-stream
       (apply proc (map stream-car argstreams))
       (apply stream-map
              (cons proc (map stream-cdr argstreams))))))
#+END_SRC
***** 3.51
#+BEGIN_SRC scheme
(define (display-line x)
  (display x) (newline))

(define (show x)
  (display-line x)
  x)

(define x (stream-map show (stream-enumerate-interval 0 10)))
; 0
(stream-ref x 5)
; 1
; 2
; 3
; 4
; 5
(stream-ref x 7)
; 6
; 7
#+END_SRC
***** 3.52
#+BEGIN_SRC scheme
(define sum 0)
(define (accum x)
  (set! sum (+ x sum))
  sum)

(define seq (stream-map accum (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                         seq))

(stream-ref y 7)
;Value: 136

(display-stream z)
10
15
45
55
105
120
190
210
;Value: done

sum
;Value 210
#+END_SRC
Had we implemented ~delay~ without the memoization the ~accum~ procedure would have modified the state of ~sum~ on each call. Since we iterated over the streams twice, once for ~y~ and once for ~z~ the sum would be much larger. Since ~sum~ is a global variable being modified each time ~accum~ is evaluated, ~sum~ would have a value of 210 after the definition of ~y~, and a value of 420 after teh definition of ~z~ because the accum procedure would fully evaluate a second time for ~z~.
*** 3.5.2 Infinite Streams
**** Defining streams implicitly
- An alternative way to specify streams is to  take advantage of delayed evaluation to define streams immplicitly.
#+BEGIN_SRC scheme
(define ones (cons-stream 1 ones))
#+END_SRC
- This works much like the definition of a recursive procedure: ~ones~ is a pair whose ~car~ is 1 and wose ~cdr~ is a promise to evaluate ~ones~. Evaluating the ~cdr~ gives us again a 1 and a promise to evaluate ~ones~.
***** Exercises
****** 3.53
#+BEGIN_SRC scheme
(define s (cons-stream 1 (add-streams s s)))
#+END_SRC
The first element of ~s~ is 1 and subsequent elements are formed by adding ~s~ to itself. Thus the ~cdr~ element of ~s~ will be ~(+ (car s) (car s))~ which becomes ~(+ 1 1)~ or ~2~. When the ~cdr~ is evaluated again the result will be ~4~ from the addition of the two second values of ~s~, each being ~2~ calculated in the prior step. The stream will proceed in evaluation doubling its value each time to form a stream of powers of 2.
****** 3.54
#+BEGIN_SRC scheme
(define (mul-streams s1 s2)
  (stream-map * s1 s2))

(define integers (cons-stream 1 (add-streams ones integers)))
(define factorials (cons-stream 1 (mul-streams factorials integers)))

(stream-ref factorials 3) ; 6
(stream-ref factorials 5) ; 120
#+END_SRC
****** 3.55
#+BEGIN_SRC scheme
(define (partial-sums s)
  (cons-stream (stream-car s)
               (add-streams (stream-cdr s)
                            (partial-sums s))))

(define partial-ints (partial-sums integers))
(stream-ref partial-ints 4)
#+END_SRC
****** 3.56
#+BEGIN_SRC scheme
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream s1car (merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream s2car (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream s1car
                               (merge (stream-cdr s1)
                                      (stream-cdr s2)))))))))

(define S (cons-stream 1 (merge (scale-stream S 2)
                                (merge (scale-stream S 3)
                                       (scale-stream S 5)))))
#+END_SRC
****** 3.57
When we compute the nth Fibonacci number with the stream ~fibs~ n-1 additions are required to determine the result. For example for the 3rd fibonacci number, 2, we have to calculate 2 additions. First ~(+ 0 1)~, then ~(+ 1 1)~ to arrive at 2. If we were not using the memoized version fo ~delay~ -- ~delay being defined as ~(lambda () <exp>)~ -- then the number of sums for the nth Fibonacci number would grow exponentially because we would have to re-evaluate the sum for each proceeding number as we calculated up to the nth number.
****** 3.58
#+BEGIN_SRC scheme
(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))


#+END_SRC

~(expand 1 7 10)~ expands into an infinite stream of repeating numbers, 142857142857...
~(expand 3 8 10)~ expands to 375
****** 3.59
Skipped
****** 3.60
Skipped
****** 3.61
Skipped
****** 3.62
Skipped
*** 3.5.3 Exploiting the Stream Paradigm
- Using streams allows us to build systems with different module boundaries than systems organized around assignment to state variables.
  - We can represent state as a "timeless" stream of values rather than as a set of variables to be updated.
- A /tableau/ is a structure that is a stream of streams.
- Streams can be particularly elegant and convenient because the entire sequence of states is available to us as a data structure that can be manipulated with a uniform set of operations.
***** Exercises
****** 3.63
 The ~sqrt-stream~ procedure (below) without the local variable definition for ~guesses~ performs redundant computations because the ~stream-cdr~ of the procedure contains a recursive call to ~sqrt-stream~ in the ~stream-map~ procedure. Whereas the procedure with the defined ~guesses~ stream is references the stream directly in the ~stream-cdr~ and there is no additional computation necessary to evaluate the next procedure.
 #+BEGIN_SRC scheme
 (define (sqrt-stream x)
   (cons-stream 1.0
                (stream-map (lambda (guess)
                              (sqrt-improve guess x))
                            (sqrt-stream x))))
 #+END_SRC
****** 3.64
 #+BEGIN_SRC scheme
 (define (stream-limit s tol)
   (let ((s1 (stream-ref s 0))
         (s2 (stream-ref s 1)))
     (if (< (abs (- s1 s2)) tol)
         s2
         (stream-limit (stream-cdr s) tol))))

 (define (sqrt x tolerance)
   (stream-limit (sqrt-stream x) tolerance))
 (sqrt 2 0.001)
 #+END_SRC
****** 3.65
 Skipped
**** Infinite streams of pairs
- To handle infinite streams, we need to devise an order of combination that ensures that every element will eventually be reached if we let our program run long enough.
#+BEGIN_SRC scheme
(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))
#+END_SRC
***** Exercises
****** 3.66
The number of pairs that precede a pair, (p1, p2), will be the total number of combinations of numbers for each (i,j) such that i <= j <= p2. Thus if the pair is (1, 100), the total  number of preceding pairs would be the sum of combinations beginning from (1, 1).
(1,1),(1,2),(2,2),(1,3),(2,3)...(1,100)
****** 3.67
#+BEGIN_SRC scheme
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map
     (lambda (p) (list (cadr p) (car p)))
     (interleave
      (stream-map (lambda (x) (list (stream-car s) x))
                  (stream-cdr t))
      (pairs (stream-cdr s) (stream-cdr t))))
    (interleave
     (stream-map (lambda (x) (list (stream-car s) x))
                 (stream-cdr t))
     (pairs (stream-cdr s) (stream-cdr t))))))
#+END_SRC
My solution above works by flipping the pairs, thus transposing over the diagonal created by the constraint i <= j, however it includes duplicates.

The solution below works, and without duplicates, by inverting the ~stream-map~ to map over the ~(stream-cdr s)~ in a new stream and interleaving it with the existing stream (which maps over ~(stream-cdr t)~ combining with ~(stream-car s)~).
#+BEGIN_SRC scheme
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list x (stream-car t)))
                (stream-cdr s))
    (interleave
     (stream-map (lambda (x) (list (stream-car s) x))
                 (stream-cdr t))
     (pairs (stream-cdr s) (stream-cdr t))))))
#+END_SRC
****** 3.68
#+BEGIN_SRC scheme
(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))
#+END_SRC
If we evaluate ~(pairs integers integers)~ with the above definition of ~pairs~ we reach the maximum recursion depth of the scheme process. This is because, without the use of ~cons-stream~ to construct the stream, there is never a ~delay~ introduced to the ~stream-cdr~ portion which is the recursive call to ~pairs~. Thus, without the ~delay~ the ~pairs~ procedure recurses infinitely in the ~interleave~ procedure. ~interleave~ needs a pair from each stream to proceed, and the ~pairs~ stream contains an infinitely recursive call that is not prevented with the use of ~delay~ to prevent its execution until ~force~d.
****** 3.69
#+BEGIN_SRC scheme
(define (triples a b c)
  (cons-stream
   (list (stream-car a) (stream-car b) (stream-car c))
   (interleave
    (stream-map (lambda (x)
                  (append (list (stream-car a)) x))
                (pairs b c))
    (triples (stream-cdr a) (stream-cdr b) (stream-cdr c)))))


(define triple-stream (triples integers integers integers))
(show-stream triple-stream 10)

(define pythagorean-triples
  (stream-filter (lambda (t)
                   (= (+ (square (car t)) (square (cadr t)))
                      (square (caddr t))))
                 trips))

(show-stream pythagorean-triples 5)
#+END_SRC
****** 3.70
#+BEGIN_SRC scheme
(define (merge-weighted s1 s2 weight)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (let ((w1 (weight s1car))
                 (w2 (weight s2car)))
             ;; if we instead use an 'else' case as we do in 'merge' then we skip over valid values in the s2 stream
             ;; since equal weights can be created from different pairs, e.g. weight 5 from (1 4) and (2 3)
             (cond ((<= w1 w2)
                    (cons-stream s1car
                                 (merge-weighted
                                  (stream-cdr s1)
                                  s2
                                  weight)))
                   ((> w1 w2)
                    (cons-stream s2car
                                 (merge-weighted
                                  s1
                                  (stream-cdr s2)
                                  weight)))))))))

(define (weighted-pairs s1 s2 weight)
  (cons-stream
   (list (stream-car s1) (stream-car s2))
   (merge-weighted
    (stream-map (lambda (x)
                  (list (stream-car s1) x))
                (stream-cdr s2))
    (weighted-pairs (stream-cdr s1) (stream-cdr s2) weight)
    weight)))

(define a (weighted-pairs integers integers (lambda (x) (apply + x))))

(define (div-2-3-5 n)
  (or (= 0 (remainder n 2))
      (= 0 (remainder n 3))
      (= 0 (remainder n 5))))

(define b (stream-filter
           (lambda (p)
             (let ((i (car p))
                   (j (cadr p)))
               (and (not (div-2-3-5 i))
                    (not (div-2-3-5 j)))))
           (weighted-pairs integers integers
                           (lambda (p)
                             (let ((i (car p))
                                   (j (cadr p)))
                               (+ (* i 2) (* j 3) (* i j 5)))))))
#+END_SRC
****** 3.71
#+BEGIN_SRC scheme
(define (cube n)
  (* n n n))
(define (stream-search s weight)
  (if (= (weight (stream-car s))
         (weight (stream-car (stream-cdr s))))
      (cons-stream
       (weight (stream-car s))
       (stream-search (stream-cdr s) weight))
      (stream-search (stream-cdr s) weight)))
(define (cube-weight p)
  (let ((i (car p))
        (j (cadr p)))
    (+ (cube i)
       (cube j))))

(define ramanujan-numbers
  (stream-search
   (weighted-pairs integers integers cube-weight)
   cube-weight))

(show-stream ramanujan-numbers 6)
1729
4104
13832
20683
32832
39312
40033
#+END_SRC
****** 3.72
Skipped
**** Streams as signals
- Streams are the computational analogs of the "signals" in a signal-processing system.
- Streams can be used to model signals by representing the value of a signal at successive time intervals as consecutive elements of a stream.
***** Exercises
****** 3.73
Here is my attempt to model the integral, but I am unsure of its correctness.
#+BEGIN_SRC scheme
(define (RC R C dt)
  (define (proc i v0)
    (cons-stream
     v0
     (add-streams (scale-stream i R)
                  (integral (scale-stream i (/ 1 C))
                            v0
                            dt))))
  proc)
(define RC1 (RC 5 1 0.5))
(show-stream (RC1 integers 0.2) 10)
#+END_SRC
****** 3.74
#+BEGIN_SRC scheme
(define (make-zero-crossings input-stream last-value)
  (cons-stream
   (sign-change-detector (stream-car input-stream) last-value)
   (make-zero-crossings (stream-cdr input-stream)
                        (stream-car input-stream))))
(define zero-crossings (make-zero-crossings sense-data 0))

;; The above is equivalent to
(define zero-crossings
  (stream-map sign-change-detector sense-data (cons-stream 0 sense-data)))
#+END_SRC
****** 3.75
#+BEGIN_SRC scheme
(define (make-zero-crossings input-stream last-value last-average)
  (let ((avpt (/ (+ (stream-car input-stream) last-value) 2)))
    (cons-stream (sign-change-detector avpt last-average)
                 (make-zero-crossings (stream-cdr input-stream)
                                      (stream-car input-stream)
                                      avpt))))
#+END_SRC
We need to included the raw ~last-value~ of the stream AND the ~last-average~ value. If we instead use the previous average as the value of ~last-value~ then we will end up continually averaging our stream with the previous average instead of smoothing our stream by averaging raw input values. We also need to check the change in sign between the current average, ~avpt~ and the previous average, ~last-average~ to ensure we are comparing the same smoothed values.
****** 3.76
#+BEGIN_SRC scheme
(define (smooth input-stream last-value)
  (define (average x y)
    (/ (+ x y) 2))
  (let ((average-val (average (stream-car input-stream) last-value)))
    (cons-stream average-val
                 (smooth (stream-cdr input-stream) (stream-car input-stream)))))

(show-stream (smooth integers 0) 10)

(define (make-zero-crossings source-signal smooth)
  (define (check-zero-crossings input-stream last-value)
    (cons-stream (sign-change-detector (stream-car input-stream) last-value)
                 (check-zero-crossings (stream-cdr input-stream) (stream-car input-stream))))
  (check-zero-crossings (smooth source-signal) 0))
#+END_SRC
*** 3.5.4 Streams and Delayed Evaluation
- ~delay~ is crucial for using streams to model signal-processing systems that contain loops. Otherwise our models would have to be formulated so that the inputs to any signal-processing component would be fully evaluated before the output could be produced. This would outlow loops.
***** Exercises
****** 3.77
 #+BEGIN_SRC scheme
 (define (integral delayed-integrand initial-value dt)
   (cons-stream initial-value
                (let ((integrand (force delayed-integrand)))
                  (if (stream-null? integrand)
                     the-empty-stream
                     (integral (delay (stream-cdr integrand))
                               (+ (* dt (stream-car integrand))
                                  initial-value)
                               dt)))))

 (stream-ref (solve (lambda (y) y) 1 0.001) 1000)
 #+END_SRC
****** 3.78
 #+BEGIN_SRC scheme
 (define (solve-2nd a b dt y0 dy0)
   (define y (integral (delay dy) y0 dt))
   (define dy (integral (delay ddy) dy0 dt))
   (define ddy (add-streams (scale-stream dy a)
                            (scale-stream y b)))
   y)
 #+END_SRC
****** 3.79
 #+BEGIN_SRC scheme
 (define (solve-2nd f dt y0 dy0)
   (define y (integral (delay dy) y0 dt))
   (define dy (integral (delay ddy) dy0 dt))
   (define ddy (stream-map f dy y))
   y)
 #+END_SRC
 Not sure about how to describe or prove the answer above.
****** 3.80
#+BEGIN_SRC scheme
(define (RLC R L C dt)
  (define (proc vC0 iL0)
    (define vC (integral (delay dvC) vC0 dt))
    (define iL (integral (delay diL) iL0 dt))
    (define dvC (scale-stream iL (/ -1 C)))
    (define diL (add-streams (scale-stream iL (/ (* R -1) L))
                            (scale-stream vC (/ 1 L))))
    (cons vC iL))
  proc)

(define test-RLC (RLC 1 1 0.2 0.1))
(define str-pairs (test-RLC 10 0))
(stream-ref (car str-pairs) 5)
(stream-ref (cdr str-pairs) 5)
#+END_SRC
**** Normal-order evaluation
- As far as anyone knows, mutability and delayed evaluation do not mix well in programming languages.
*** 3.5.5
***** Exercises
****** 3.81
Skipped
****** 3.82
Skipped
**** A functional-programming view of time
- Streams provide an alternative way to model objects with local state.
  - We can model a changing quantity, such as the local state of some object, using a stream that represents the time history of successive states.
- In /functional programming languages/ all procedures implement well-defined mathematical functions of their arguments, whose behavior does not change.
  - There are no provisions for assignment or mutable data.
