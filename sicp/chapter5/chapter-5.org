* Chapter 5 - Computing with Register Machines
- A /register machine/ (a computer) sequentially executes /instructions/ that manipulate the contents of a fixed set of storage elements called /registers/
  - A typical register machine instruction applies a primitive operation to the contents of some registers and assigns the result to another register.
** 5.1 Designing Register Machines
- To design a register machine, we must design its /data path/ (registers and operations) and the /controller that sequences these operations.
**** Exercises
***** 5.1
Diagramming done on paper. Description below:

'product' and 'counter' registers with two operations, 'multiply' and 'increment' that store their results in temporary registers 't1' and 't2' respectively. The inputs to 'multiply' are 'product' and 'counter' and the result is stored in 't1'. The inputs to 'increment' are 'counter' and the constant value '1' and the result is stored in 't2'. There is a test for whether 'counter' is greater than the register that stores 'n'.
The controller diagram starts with the greater-than test, if the test passes we are done, if not we proceed in the following order: move the value store in 't1' to the 'product' register, move the value stored in 't2' to the 'counter' register and repeat the test.
*** 5.1.1 A Language for Describing Register Machines
- The controller of a machine is defined as a sequence of /instructions/ together with /labels/ that identify /entry points/ in the sequence.
  - Instructions are one of:
    - The name of a data-path button to push to assign a value to a register
    - A ~test~ instruction that performs a specified test
    - A conditional branch (~branch~ instruction) to a location indicated by a controller label, based on the result of the previous test
      - If the test fails the controller should continue with the next instruction in the sequence, otherwise it should continue with the instruction after the label.
    - An unconditional branch (~goto~ instruction) naming a controller label at which to continue execution
- The machine starts at the beginning of the controller instruction sequence and stos when execution reaches the end of the sequence.
**** Exercises
***** 5.2
#+BEGIN_SRC
(controller
 test-counter
   (test (op >) (reg counter) (const 0))
   (branch (label fact-done))
   (assign t1 (op multiply) (reg product) (reg counter))
   (assign t2 (op increment) (reg counter) (const 1))
   (assign product (reg t1))
   (assign counter (reg t2))
   (goto (label test-counter))
 fact-done)
#+END_SRC
*** 5.1.2 Abstraction in Machine Design
**** Exercises
***** 5.3
Diagrams drawn on paper. Controller definition below:

#+BEGIN_SRC
(controller
 test-guess
   (goto (label good-enough))
 improve
   (assign div-res (op /) (reg x) (reg guess))
   (assign t2 (op average) (reg div-res) (reg guess))
   (assign guess (reg t2))
 good-enough
   (assign square-res (op square) (reg guess))
   (assign t1 (op -) (reg x) (reg square-res))
   (test (op >) (reg t1) (const 0.001))
   (branch (label good-enough-done))
   (goto (label improve))
 good-enough-done
   (assign guess (reg t1))
 sqrt-done)
#+END_SRC
*** 5.1.3 Subroutines
- Similar sequences of instructions in the controller can be replaced by a single sequence, a /subroutine/.
  - To enable the use of subroutines we need to know which label to continue execution at when the subroutine completes, this can be accomplished using a special /continue/ register.
*** 5.1.4 Using a Stack to Implement Recursion
- When solving a recursive subproblem the machine needs to save the contents of any registers that will be needed after the subproblem is solved in order to be able to continue the suspended computation.
  - These values must be restored in the reverse of teh order in which they were saved, since in a nest of recursions the last subproblem to be entered is the first to be finished.
    - This dictates the use of a /stack/, or "last in, first out" data structure, to save register values
**** Exercises
***** 5.4
Diagrams done on paper, controller instruction sequences below
****** a
#+BEGIN_SRC
(controller
   (assign continue (label expt-done)) ;; set up final return address
 expt-loop                           ;; expt loop
   (test (op =) (reg n) (const 0))
   (branch (label base-case))
   (save continue)                     ;; save the continue label on the stack.
   ;; No need to save 'n' because it is just a counter and not needed in further computation
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-expt))
   (goto (label expt-loop))
 after-expt
   (restore continue)
   (assign val (op *) (reg b) (reg val))
   (goto (reg continue))
 base-case                           ;; base-case
   (assign val (const 1))
   (goto (reg continue))
 expt-done)
#+END_SRC
****** b
#+BEGIN_SRC
(controller
   (assign counter (reg n))
   (assign product (const 1))
 expt-loop
   (test (op =) (reg counter) (const 0))
   (branch (label expt-done))
   (assign product (op *) (reg product) (reg b))
   (assign counter (op -) (reg counter) (const 1))
   (goto expt-loop)
 expt-done)
#+END_SRC
***** 5.5
Skipped
***** 5.6
The extra ~save~ and ~restore~ instructions in the Fibonacci machine in Figure 5.12 are for the ~n~ register. Since ~n~ is just storing a counter and is not needed to perform the computations of the Fibonacci value -- it is just needed to determine when we've reached out base case -- there is no need to keep track of it on the stack. The two values we need to keep track of are the ~continue~ label and the ~val~ accumulation.
*** 5.1.5 Instruction Summary
** 5.2 A Register-Machine Simulator
**** Exercises
***** 5.7
Skipped, we do not have the simulator for the machine yet.
*** 5.2.1 The Machine Model
- The basic machine model, constructed in ~make-machine~ by the ~make-new-machine~ procedure, is essentially a container for some registers and a stack together with an execution mechanism that processes the controller instructions one by one.
  - ~make-machine~ then extends this basic model to include the registers, operations, and controller of the particular machine being defined.
    - It uses an /assembler/ to transform the controller list into instructions for the new machine and installs these as the machine's instruction sequence.
*** 5.2.2 The Assembler
- The assembler transforms the sequence of controller expressions for a machine into a corresponding list of machine instructions, each with its execution procedure.
**** Exercises
***** 5.8
With the simulator written as-is, the contents of register ~a~ will be ~4~ because the second ~here~ label entry will be created and will be placed in front of the first ~here~ label entry in the labels table during assembly, thus when the program is executied the instructions under ~start~ will be executed and the ~goto~ instruction will lookup the second ~here~ label (which is first in the label table) and execute instructions starting from that label, assigning ~a~ to be ~4~.

To avoid this we need to signal an error if we attempt to define duplicate labels.
#+BEGIN_SRC scheme
(define (extract-labels text receive-proc)
  (if (null? text)
      (receive-proc '() '())
      (extract-labels (cdr text)
                      (lambda (insts labels)
                        (let ((next-inst (car text)))
                          (if (symbol? next-inst)
                              (let ((val (assoc next-inst labels)))
                                (if val
                                    (error "Already defined label -- ASSEMBLE" next-inst)
                                    (receive-proc insts
                                             (cons (make-label-entry next-inst
                                                                     insts)
                                                   labels))))
                              (receive-proc (cons (make-instruction next-inst)
                                                  insts)
                                            labels)))))))
#+END_SRC
*** 5.2.3 Generating Execution Procedures for Instructions
- For each type of instruction in the register-machine language there is a generator that builds an appropriate execution procedure.
  - The details of these procedures determine both the syntax and meaning of the individual instructions in the register-machine language.
  - We use data abstraction to isolate the detailed syntax of register-machine expressions from the general execution mechanisms by using syntax procedures to extract and classify the parts of an instruction.
**** Exercises
***** 5.9
#+BEGIN_SRC scheme
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (if (label-exp? e)
                    (error "Operations can only be used with register and constant operands -- ASSEMBLE" e)
                    (make-primitive-exp e machine labels)))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
#+END_SRC
***** 5.10
Skipping the creation of a new syntax
***** 5.11
****** a
We can replaces the following instructions:
#+BEGIN_SRC scheme
afterfib-n-2
  (assign n (reg val))
  (restor val)
  ...
#+END_SRC
With ~(restore n)~. At this point in the program the saved value of ~n~ is equal to ~Fib(n-2)~ and ~val~ is equal to ~Fib(n-1)~. Instead of shifting the values around if we restore into ~n~ that last value on the stack, ~Fib(n-2)~, then the procedures below will still be computing ~Fib(n-1) + Fib(n-2)~.
****** b
#+BEGIN_SRC scheme
(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            ((eq? message 'name) name)  ;; add a dispatch to return the name given to the register
            (else
             (error "Unknown request -- REGISTER" message))))
    dispatch))

;; helper function to get a register's name
(define (get-register-name reg)
  ((reg 'name)))

(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (cons (get-register-name reg) (get-contents reg)))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (if (equal? (stack-inst-reg-name)
                  (get-register-name reg))
          (begin
            (set-contents! reg (cadr (pop stack))) ;; get the value since we are pushing a pair onto the stack now
            (advance-pc pc))
          (error "Attempting to restore to different register -- ASSEMBLE" reg)))))
#+END_SRC
****** c
#+BEGIN_SRC scheme
(define (make-register name)
  (let ((contents '*unassigned*)
        (stack (make-stack)))  ;; add a local stack to the register
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            ;; add a dispatch message to initialize the stack
            ((eq? message 'initialize-stack)
             (lambda () (stack 'initialize)))
            ((eq? message 'stack) stack)
            (else
             (error "Unknown request -- REGISTER" message))))
    dispatch))

(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        ;; remove the machine stack in favor of register local stacks
        (the-instruction-sequence '()))
    (let ((register-table
            (list (list 'pc pc) (list 'flag flag))))
      (let ((the-ops
             (list (list 'initialize-stack (lambda ()
                                             ;; For each register allocated in the machine initialize the register's local stack
                                             (for-each (lambda (reg) (reg 'initialize-stack)))
                                             (map (lambda (reg-table-entry) (cadr reg-table-entry))
                                                  register-table))))))
       (define (allocate-register name) ...)
       ))))

;; update save and restore to reference the register's local stack
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push (reg 'stack) (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop (reg 'stack)))
      (advance-pc pc))))
#+END_SRC
***** 5.12
The full methods that were added or updated for the exercise in the machine simulator are included below:
#+BEGIN_SRC scheme
;; Ex 5.12 insert into a sorted list
;; for keeping track of instructiions etc
(define (insert-expr exp list)
  (cond ((null? list) (cons exp list))
        ((not (equal? exp (car list)))
         (cons (car list) (insert-expr exp (cdr list))))))

(define (insert-sorted inst list)
  (cond ((null? list) (cons inst '()))
        ((eq? inst (car list)) list)
        ((symbol<? inst (car list))
         (cons inst list))
        (else (cons (car list) (insert inst (cdr list))))))

(define (make-register name)
  (let ((contents '*unassigned*)
        (value-sources '()))
    (define (add-value-source value-expr)
      (set! value-sources (insert-expr value-expr value-sources)))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            ((eq? message 'name) name) ;; Ex 5.12
            ((eq? message 'add-value-source) add-value-source)  ;; Ex 5.12
            ((eq? message 'get-value-sources) value-sources) ;; Ex 5.12
            (else
             (error "Unknown request -- REGISTER" message))))
    dispatch))

(define (get-register-name register)
  (register 'name))

;; ...

(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '())
        (seen-instructions '())       ;; ex 5.12
        (goto-registers '())          ;; ex 5.12
        (save-restore-registers '())) ;; ex 5.12
    (let ((the-ops
           (list (list 'initialize-stack (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register: " name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      ;; Ex 5.12 --
      (define (add-instruction inst)
        (set! seen-instructions (insert-sorted inst seen-instructions)))
      (define (add-goto-reg reg)
        (set! goto-registers (insert-sorted reg goto-registers)))
      (define (add-save-restore-reg reg)
        (set! save-restore-registers (insert-sorted reg save-restore-registers)))
      (define (register-value-sources)
        (map (lambda (reg-table-entry)
                    (let ((register (cadr reg-table-entry))
                          (reg-label (car reg-table-entry)))
                      (cons reg-label (register 'get-value-sources))))
                  register-table))
      ;; -- end Ex 5.12 procedures
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              ;; -- Ex 5.12
              ((eq? message 'add-inst) add-instruction)
              ((eq? message 'add-goto-reg) add-goto-reg)
              ((eq? message 'add-save-restore) add-save-restore-reg)
              ((eq? message 'seen-instructions) seen-instructions)
              ((eq? message 'goto-registers) goto-registers)
              ((eq? message 'save-restore-registers) save-restore-registers)
              ((eq? message 'register-value-sources) (register-value-sources))
              ;; end Ex 5.12 --
              (else (error "Unknown request -- MACHINE" message))))
      dispatch)))

;; ...

(define (make-execution-procedure inst labels machine pc flag stack ops)
  ((machine 'add-inst) (car inst)) ;; Ex 5.12
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Unknown instruction type -- ASSEMBLE" inst))))

(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             ((machine 'add-goto-reg) (get-register-name reg)) ;; Ex 5.12
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction -- ASSEMBLE"
                       inst)))))

(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    ((machine 'add-save-restore) (get-register-name reg)) ;; Ex 5.12
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    ((machine 'add-save-restore) (get-register-name reg)) ;; Ex 5.12
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc))))

#+END_SRC

Code to test the changes to the simulator above to record instructions:
#+BEGIN_SRC scheme
(define fib-controller
  '(controller
    (assign continue (label fib-done))
    fib-loop
    (test (op <) (reg n) (const 2))
    (branch (label immediate-answer))
    (save continue)
    (assign continue (label afterfib-n-1))
    (save n)
    (assign n (op -) (reg n) (const 1))
    (goto (label fib-loop))
    afterfib-n-1
    (restore n)
    (restore continue)
    (assign n (op -) (reg n) (const 2))
    (save continue)
    (assign continue (label afterfib-n-2))
    (save val)
    (goto (label fib-loop))
    afterfib-n-2
    (assign n (reg val))
    (restore val)
    (restore continue)
    (assign val (op +) (reg val) (reg n))
    (goto (reg continue))
    immediate-answer
    (assign val (reg n))
    (goto (reg continue))
    fib-done))

(define fib-machine
  (make-machine
   '(n continue val)
   (list (list '- -) (list '+ +) (list '< <))
   fib-controller))

(display (fib-machine 'seen-instructions))
(display (fib-machine 'goto-registers))
(display (fib-machine 'save-restore-registers))
(display (fib-machine 'register-value-sources))
#+END_SRC
***** 5.13
Skipped
*** 5.2.4 Monitoring Machine Performance
- Simulation is useful not only for verifying the correctness of a proposed machine design but also for measuring the machine's performance.
**** Exercises
***** 5.14
Skipped
***** 5.15
Included in the machine simulator with comments marking the exercise around the added code.
***** 5.16
Included in the machine simulator with comments marking the exercise around the added code.
***** 5.17
Included in the machine simulator with comments marking the exercise around the added code.
***** 5.18
Included in the machine simulator with comments marking the exercise around the added code.
***** 5.19
Included in the machine simulator with comments marking the exercise around the added code. Skipped the ~cancel-breakpoint~ part.
** 5.3 Storage Allocation and Garbage Collection
- Lisp systems provide an /automatic storage allocation/ /facility to support the illusion of an infinite memory.
  - When a data object is no longer needed, the memory allocated to it is automatically recycled and used to construct new data objects.
  - One such technique for achieving this is /garbage collection/
*** 5.3.1 Memory as Vectors
- Typical memory systems provide two primitive operations: one that fetches the data stored in a specified location and one that assignes hnew data to a specified location
- Many important data operations require that memory addresses (locations of data in memory) be treated as data which can be stored in memory locations and manipulated in machine registers; /address arithmetic/.
- To model computer memory, we use a data structure called a /vector/
  - Abstractly a vecotr is a compound data object whose individual data elements can be accesses by means of an integer index in an amount of time that is independent of the index
    - This is not the same as a list where the access time is _not_ independent of the index since accessing the nth element of a list requires n - 1 ~cdr~ operations
  - For computer memory, this access can be implemented through the use of address arithmetic to combine a /base address/ that specifies the beginning location of a vector in memory with an /index/ that specifies the offset of a particular element in the vector
- In our example, since we want two instances of a symbol to be recognized as the "same" symbol by ~eq?~ and we want ~eq?~ to be a simple test for equality of pointers we must ensure that if the reader sees the same character string twice it will use the same points (to the same sequence of characters) to represent both occurrences.
  - To accomplish this the reader maintains a table -- traditionally called the /obarray/ -- of all the symbols is has ever encountered. When the reader encounters a characters string it looks in the /obarray/ table to see if it has seen the same characters string every before and if it has it returns the pointer stored in the obarray, if it has not it uses the sequence of characters to constuct a new symbol and enters the pointer in the obarray.
    - This process of replacing character strings by unique pointers is called /interning/ symbols.
**** Exercises
***** 5.20
Done on paper.
***** 5.21
****** a
Not sure about the difference between this an b yet?
****** b
#+BEGIN_SRC scheme
(define count-leaves-machine
  (make-machine
   '(count node left right continue)
   (list (list '+ +) (list '= =) (list 'eq? eq?) (list 'null? null?) (list 'pair? pair?) (list 'car car) (list 'cdr cdr))
   '(controller
     (assign count (const 0))
     (assign continue (label done))

     tree-loop
     (test (op null?) (reg node))
     (branch (label null-node))
     (test (op pair?) (reg node))
     (branch (label count-left))
     (goto (label non-pair))

     count-left
     (save continue)
     (save node)
     (assign continue (label count-right))
     (assign node (op car) (reg node))
     (goto (label tree-loop))

     count-right
     (restore node)
     (restore continue)
     (assign node (op cdr) (reg node))
     (goto (label tree-loop))

     null-node
     (goto (reg continue))

     non-pair
     (assign count (op +) (reg count) (const 1))
     (goto (reg continue))

     done)))

(set-register-contents! count-leaves-machine 'node '(a (b c (d)) (e f) g))
(start count-leaves-machine)
(get-register-contents count-leaves-machine 'node)
(get-register-contents count-leaves-machine 'count)
#+END_SRC
***** 5.22
#+BEGIN_SRC scheme
(define append-machine
  (make-machine
   '(one two tmp ltmp output continue)
   (list (list 'null? null?) (list 'car car) (list 'cdr cdr) (list 'cons cons))
   '(start
     (assign ltmp (reg one))
     (assign continue (label done))
     (assign output (reg two))

     iter
     (test (op null?) (reg ltmp))
     (branch (label build-list))
     (save continue)
     (assign continue (label build-list))
     (assign tmp (op car) (reg ltmp))
     (save tmp)
     (assign ltmp (op cdr) (reg ltmp))
     (goto (label iter))

     build-list
     (restore tmp) ;; get value off stack
     (assign output (op cons) (reg tmp) (reg output))
     (restore continue)
     (goto (reg continue))

     done)
   ))

(set-register-contents! append-machine 'one '(1 2 3))
(set-register-contents! append-machine 'two '(4 5 6))
(start append-machine)
(get-register-contents append-machine 'output)
#+END_SRC

#+BEGIN_SRC scheme
(define append-splice-machine
  (make-machine
   '(one two car-one)
   (list (list 'null? null?) (list 'car car) (list 'cdr cdr) (list 'cons cons))
   '(controller

     iter
     (save car-one)
     (test (op null?) (reg one))
     (branch (label append))
     (assign car-one (op car) (reg one))
     (assign one (op cdr) (reg one))
     (goto (label iter))

     append
     (restore car-one)
     (test (op null?) (reg car-one))
     (branch (label done))
     (assign two (op cons) (reg car-one) (reg two))
     (goto (label append))

     done
     )))

(set-register-contents! append-splice-machine 'one '(1 2 3))
(set-register-contents! append-splice-machine 'two '(4 5 6))
(set-register-contents! append-splice-machine 'car-one '())
(start append-splice-machine)
(get-register-contents append-splice-machine 'one)
(get-register-contents append-splice-machine 'two)
#+END_SRC
The resulting appended list is in register ~two~
*** 5.3.2 Maintaining the Illusion of Infinite Memory
- In order to recycle pairs we must have a way to determine which allocated pairs are not needed (in the sense that their contents can no longer influence the future of the computation).
- A method for accomplishing this is called /garbage collection/
  - Garbage collection is based on the observation that, at any moment in a Lisp program interpretation, the only objects that can affect the future of the computation are those that can be reached by some succession of ~car~ and ~cdr~ operations starting from the pointers that are currently in the machine registers. Any memory cell that is not so accessible may be recycled.
    - One method of garbage collection is /stop-and-copy/ in which memory is divided into two halves, "working memory" and "free memory". ~cons~ constructs pairs by allocating in working memory and when working memory is full garbage collection is performed in which we locate all the useful pairs in working memory and copy them to the "free memory" segment. After this is done the two memory segments responsibilities are swapped and working memory becomes the new free memory, and vice versa
      - Another advantage of the /stop-and-copy/ GC method is that it is a /compacting/ garbage collection method; meaning at the end of the garbage collection phase all the useful data will be moved over to consecutive memory locations
- Example of /stop-and-copy/ as register machine instructions
#+BEGIN_SRC scheme
begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root)) ;;  old root
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip)) ;; pointers 'free' and 'scan' are the same, gc is done, cleanup
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-results-in-new))
update-car
  (perform
   (op vector-set!) (reg new-cars) (reg scan) (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))
relocate-old-results-in-new
  (test (op pointer-to-pair?) (reg old)) ;; does the pointer in 'old' represent a pair that needs to be moved?
  (branch (label pair)) ;; it does represent a pair, move the pair
  (assign new (reg old)) ;; it doesn't represent a pair, a number perhaps, so we don't need to move it, return the pointer in the 'new' register
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) ;; new location for pair
  ;; Update free pointer
  (assign free (op +) (reg free) (const 1))
  (perform (op vector-set!)
           (reg the-cars) (reg new) (reg oldcr)) ;; set the nth value, which is held by new and references the previous free pointer value, to the value of oldcr
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new)) ;; set the forwarding address in the old cdr cell to the cell in the new cars
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
#+END_SRC
** 5.4 The Explicit-Control Evaluatore
- The /explicit control evaluator/ in this section shows how the underlying procedure-calling and argument-passing mechanisms used in the evaluation process can be described in terms of operations on registers and stacks.
- The evaluator register machine here contains a stack and seven registers
  - ~exp~ is used to hold the expression to be evaluated
  - ~env~ contains the environment in which the evaluation is performed
  - ~val~ contains teh value obtained by evaluating the expression in the designated environment, at the end of evaluation
  - ~continue~ is used to implement recursion
  - ~proc~ used in evaluating combinations
  - ~argl~ used in evaluating combinations
  - ~unev~ used in evaluating combinations
*** 5.4.1 The Core of the Explicit-Control Evaluator
- In our controller the dispatch is written as a sequence of ~test~ and ~branch~ instructions. Alternatively it could have been written in a data-directed style to avoid the need to perform sequential tests and to facilitate the definition of new expression types.
- By the time we get to ~apply-dispatch~ the ~proc~ register contains the procedure to apply and ~argl~ contains the list of evaluated arguments to which it must be applied.
- To specify how the machine handles primitives we would have to provide a sequence of controller instructions to implement each primitive and arrange for ~primitive-apply~ to dispatch to the instructions for the primitive identified by the contents of ~proc~. Instead in this example we just us the underlying Scheme system to apply the procedure (~proc~) to the arguments (~argl~).
- To apply a compound procedure we first construct a frame that binds the procedure's parameters to the arguments, use this frame to extend the environment carried by the procedure, and evaluate in this extended environment the sequence of expressions that forms the body of the procedure.
*** 5.4.2 Sequence Evaluation and Tail Recursion
- An evaluator that can execute a procedure without requiring increasing storage as the procedure continues to call itself is called a /tail-recursive/ evaluator.
  - The evaluator in this example is tail-recursive because in order to evaluate the final expression of a sequence we transfer directly to ~eval-dispatch~ without saving any information on the stack.
    - Evaluating the final expression in a sequence will not cause any information to be accumulated on the stack
    - The implementation of tail recursion in ~ev-sequence~ is one variety of a well-known optimization technique used by many compilers. In compiling a procedure that ends with a procedure call, one can replace the call by a jump to the called procedure's entry point.
    - Without a tail-recursive implementation, procedure evaluation will require space proportional to the number of iterations rather than requiring constant space as it would in a tail-recursive implementation. This difference can result is procedure evaluation using up the space allocated for the stack.
*** 5.4.3 Conditionals, Assignments, and Definitions
- Special forms are handled by selectively evaluating fragments of the expression
**** Exercises
***** 5.23
#+begin_src scheme
ev-let
  (assign exp (op let->lambda) (reg exp)) ;; transform the let expression in 'exp' to a sequence of lambda expressions
  (goto (label eval-dispatch))
ev-cond
  (assign exp (op cond->if) (reg exp)) ;; transform cond into sequence of if expressions and eval
  (goto (label eval-dispatch))
#+end_src
***** 5.24
Skipped
***** 5.25
Skipped
*** 5.4.4 Running the Evaluator
- Simulations can be a powerful tool to guid the implementation of evaluators.
  - They make it easy to explore variations of the register-machine design and also monitor the performance of the simulated evaluator
**** Exercises
***** 5.26
Skipped
***** 5.27
Skipped
***** 5.28
Skipped
***** 5.29
Skipped
***** 5.30
Skipped
** 5.5 Compilation
- Commercial general-purpose computers are register machines organized around a collection of registers and operations that constitute an efficient and convenient universal set of data paths.
- The controller for general-purpose machineis an interpreter for a register-machine language like the one we have been using.
  - This language is called the /native language/ of the machine, the /machine language/
- There are two common strategies for bridging the gap between higher-level languages and machine-languages.
  - **Interpretation** - an interpreter written in the native language of a machine configures the machine to execute programs written in a language --  the /source language/ -- that may differ from the native language of the machine.
    - Primitive procedures of the source language are implemented as a library of subroutines written in the native language of the given machine.
    - A program to be interpreted is represented as a data structure that the interpreter traverses, analyzing the source program, and while doing so it simulates the intended behavior of the source program by calling approriate primitive subroutines from the library
  - **Compilation** - a compiler for a given source language and machine translates a source program into an equivalent program -- called the /object program/ -- written in the machine's native language.
- Compilation can provide a great increase in the efficiency of program execution. On the other hand interpretation provides a more powerful environment for interactive program development and debugging becuase the source program being executed is available at run time to be examined and modified.
*** 5.5.1 Structure of the Compiler
- ~compile~ performs a case anaylsis on the syntactic type of the expression to be compiled and for each type of expression it dispatches to a specialized /code generator/
  - ~compile~ and the code generators take three arguments: ~exp~, ~target~, and ~linkage~
    - ~exp~ - the expression to compile
    - ~target~ - specifies the register in which the compiled code is to return the value of the expression
    - ~linkage~ descriptor - describes how the code resulting fro mthe compilation of the expression should proceed when it has finished execution.
      - in this example the ~linkage~ descriptor can specify the code continue at the next instructions (~next~), return from the procedure being compiled (~return~) or jump to a named entry point (~<label>~)
- Each code generator returns an /instruction sequence/ containing the object code it has generated for the expression.
**** Exercises
***** 5.31
- ~(f 'x 'y)~ - This one does need the ~env~ to be saved as we only need to look up ~f~ in the current environment
- ~((f) 'x 'y)~ - Here we need to save ~env~ so we can use it after we evaluate ~(f)~, when applying the result of ~(f)~ to ~'x~ and ~'y~
- ~(f (g 'x) y)~ - Here we need to save ~env~, ~proc~ and ~argl~ because we need to evaluate the second argument in a new environment before applying the current ~proc~, ~f~, to it, and we will also need to lookup the variable value of ~y~ before applying ~f~.
- ~(f (g 'x) 'y)~ Here we need to save the ~argl~ and ~proc~ because of the evaluation of the second argument, but we do not need to save the ~env~ because ~'y~ is quoted and thus does not need to be looked up in the ~env~ and it will not be impacted by an environment change
***** 5.32
Skipped
*** 5.5.2 Compiling Expressions
- In general, the output of each code generator will end with instructions that implement the required linkage.
- When compiling ~lambda~ expressions we need to compile the procedure object and the procedure body. The procedure object is constructed at runtime, it combines the current environment with the entry point to the compiled procedure body (a newly generated label);
*** 5.5.3 Compiling Combinations
- The essence of the compilation process is the compilation of procedure applications.
*** 5.5.4 Combining Instruction Sequences
*** 5.5.5 An Example of Compiled Code
**** Exercises
***** 5.33
Skipped
***** 5.34
Skipped
***** 5.35
Skipped
***** 5.36
Skipped
***** 5.37
Skipped
***** 5.38
Skipped
*** 5.5.6 Lexical Addressing
- One of the most common optimizations performed by compilers is the optimization of variable lookup.
  - Our current example compiler looks up variables by checking the environments and working out frame by frame until it find the variable. This can be expensive
  - An improved we can make is to lookup variables using lexical addressing.
    - Since our language is lexically scoped -- the inner blocks have access to the variables and declarations of the outer blocks -- the run time environment for any expression will have a structure that parallels the lexical structure of the program in which the expression appears. The run time environment will have inner frames contained within outer frames.
      - We can use a /lexical address/ that consists of two number: a /frame number/ which specifies how many frames to pass over, and a /displacement number/ which specifies how many variables to pass over in that frame, to more effieciently lookup variables without needing to scan through each frame.
      - The compiler can maintain a data structure called a /compile-time environment/ to keep track of which variables will be at which positions in which frames in the run-time environment in order to produce code that uses lexical addressing.
**** Exercises
***** 5.39
Skipped
***** 5.40
Skipped
***** 5.41
Skipped
***** 5.42
Skipped
***** 5.43
Skipped
***** 5.44
Skipped
*** 5.5.7 Interfacing Compiled Code to the Evaluator
- An interpreter raises the machine to the level of the user program.
  - Interpreters are good for interactive program development and debugging because the steps of program execution are organized in terms of these abstractions
- A compiler lowers the user program to the level of the level of the machine language.
  - Compiled code can execute faster because the steps of program execution are organized in terms of the machine language, and the compiler is free to make optimizations that cut across the higher-level abstractions
**** Exercises
***** 5.45
Skipped
***** 5.46
Skipped
***** 5.47
Skipped
***** 5.48
Skipped
***** 5.49
Skipped
***** 5.50
Skipped
***** 5.51
Skipped
***** 5.52
Skipped
