* Chapter 2 Building Abstractions with Data
- /compound data/ are abstractions built by combining data objects
** 2.1 Introduction to Data Abstraction
- /data abstraction/ is a methodology that enables us to isolate how a compound data object is used from the details of how it is constructed from more primitive data objects
*** 2.1.1 Example: Arithmetic Operations for Rational Numbers
- a /pair/ is a compound data structure that can be constructed with the primitive procedure ~cons~.
  - Given a pair you can extract the parts using ~car~ and ~cdr~.
  - Data objects constructed from pairs are called /list-structured/ data
**** Exercises
***** 2.1
#+BEGIN_SRC scheme
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (print-rat x)
  (display (numer x))
  (display "/")
  (display (denom x)))
(define (make-rat n d)
  (let* ((g (gcd n d))
         (ng (/ n g))
         (dg (/ d g)))
    (cond ((and (< n 0) (< d 0))
           (cons ng dg))
          ((or (< n 0) (< d 0))
           (cons (- ng) (abs dg)))
          (else (cons ng dg)))))

(print-rat (make-rat 1 2))
(print-rat (make-rat -1 2))
(print-rat (make-rat -1 -2))
(print-rat (make-rat 1 -2))
#+END_SRC
*** 2.1.2 Abstraction Barriers
- /abstraction barriers/ isolate the functionality of each "level" of a system
  - Procedures at each level are the interfaces that define the abstraction barriers and connect the different levels
**** Exercises
***** 2.2
#+BEGIN_SRC scheme
(define (make-segment start end)
  (cons start end))
(define (start-segment segment)
  (car segment))
(define (end-segment segment)
  (cdr segment))
(define (make-point x y) (cons x y))
(define (x-point point) (car point))
(define (y-point point) (cdr point))

(define (average x y) (/ (+ x y) 2))
(define (midpoint-segment segment)
  (let ((start (start-segment segment))
        (end (end-segment segment)))
    (make-point (average (x-point start) (x-point end))
                (average (y-point start) (y-point end)))))

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))

(define start (make-point 0 0))
(define end (make-point 10 10))
(define seg (make-segment start end))
(define mid (midpoint-segment seg))
(print-point mid)
#+END_SRC
***** Exercise 2.3
#+BEGIN_SRC scheme
(define (make-rect start end)
  (make-segment start end))
(define (height-rect segment)
  (let ((start (start-segment segment))
        (end (end-segment segment)))
    (abs (- (x-point start) (x-point end)))))
(define (width-rect segment)
  (let ((start (start-segment segment))
        (end (end-segment segment)))
    (abs (- (y-point start) (y-point end)))))
(define (area-rect rect)
  (let ((h (height-rect rect))
        (w (width-rect rect)))
    (* h w)))
(define (perim-rect rect)
  (let ((h (height-rect rect))
        (w (width-rect rect)))
  (+ (* h 2) (* w 2))))

(define rect (make-rect
              (make-point 2 2)
              (make-point 6 7)))

(area-rect rect)
(perim-rect rect)

(define (make-rect-2 height width)
  (cons height width))
(define (height-rect rect) (car rect))
(define (width-rect rect) (cdr rect))

(define rect2 (make-rect-2 4 6))
(area-rect rect2)
(perim-rect rect2)
#+END_SRC
*** 2.1.3 What Is Meant by Data?
- Data can be thought of as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation.
**** Exercises
***** 2.4
#+BEGIN_SRC scheme
(define (cdr z)
  (z (lambda (p q) q)))
#+END_SRC
***** 2.5
Skipped
***** 2.6
Skipped
*** 2.1.4 Extended Exercise: Interval Arithmetic
#+BEGIN_SRC scheme
(define (make-interval a b) (cons a b))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (mul-interval x
                (make-interval (/ 1.0 (upper-bound y))
                               (/ 1.0 (lower-bound y)))))
#+END_SRC
**** Exercises
***** 2.7
#+BEGIN_SRC scheme
(define (lower-bound intv) (car intv))
(define (upper-bound intv) (cdr intv))
#+END_SRC
***** 2.8
To subtract intervals subtract the lowest /x/ value by the highest /y/ value, then subtract the highest /x/ value by the lowest /y/ value
/[x1, x2] - [y1, y2] = [x1-y2, x2-y1]/
#+BEGIN_SRC scheme
(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))
#+END_SRC
***** 2.9
#+BEGIN_SRC scheme
(define (width interval)
  (- (upper-bound interval) (lower-bound interval)))

(define interval-one (make-interval 1 5))
(define interval-two (make-interval 3 7))
(if (= (width (add-interval interval-one interval-two))
       (+ (width interval-one) (width interval-two)))
    #t
    #f)
; #t

(if (= (width (sub-interval interval-one interval-two))
       (+ (width interval-one) (width interval-two)))
    #t
    #f)
; #t

(if (= (width (mul-interval interval-one interval-two))
       (+ (width interval-one) (width interval-two)))
    #t
    #f)
; #f

(if (= (width (div-interval interval-one interval-two))
       (+ (width interval-one) (width interval-two)))
    #t
    #f)
; #f
#+END_SRC
***** 2.10
#+BEGIN_SRC scheme
(define (width interval)
  (- (upper-bound interval) (lower-bound interval)))
(define (span-zero? x)
  (> (width x) (upper-bound x)))
(define (div-interval x y)
  (if (span-zero? y)
      (error "Attempting to divide with an interval that spans 0")
      (mul-interval x
                    (make-interval (/ 1.0 (upper-bound y))
                                   (/ 1.0 (lower-bound y))))))

(div-interval (make-interval 1.0 4.0)
              (make-interval 2.0 5.0))
(div-interval (make-interval -1.0 4.0)
              (make-interval 2.0 5.0))
(div-interval (make-interval 1.0 4.0)
              (make-interval -2.0 5.0))
#+END_SRC
***** 2.11
Skipped
***** 2.12
#+BEGIN_SRC scheme
(define (make-center-percent center percent)
  (let ((diff (* center (/ percent 100.0))))
    (make-interval (- center diff) (+ center diff))))
(define (percent i)
  (let ((half-width (/ (- (upper-bound i) (lower-bound i)) 2)))
    (* (/ half-width (+ (lower-bound i) half-width))
       100)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))

(define i (make-center-percent 10 20))
(percent i)
(center i)
#+END_SRC
***** 2.13
Skipped
***** 2.14
Skipped
***** 2.15
Skipped
***** 2.16
Skipped
** 2.2 Hierarchical Data and the Closure Property
- The /closure property/ is satisfied when the results of an operation combining objects can themselves be combined using the same operation.
  - ~cons~ satisfies this, the results of ~cons~-ing two objects can themselves be ~cons~-ed into another object
  - Closure is important because it allows us to create /hierarchical/ structures -- structures made up of parts (turtles all the way down)
*** 2.2.1 Representing Sequences
- A /sequence/ is an ordered collection of data objects
  - A sequence of pairs formed by nested ~cons~es is called a /list/. And the Scheme primitive ~list~ constructs them.
#+BEGIN_SRC scheme
(list <a1> <a2> ... <aN>)
; equivalent to nested cons
(cons <a1> (cons <a2 (cons ... (cons <aN> nil) ... )))
#+END_SRC
**** Exercises
***** 2.17
#+BEGIN_SRC scheme
(define (last-pair l)
  (if (null? (cdr l))
      l
      (last-pair (cdr l))))
#+END_SRC
***** 2.18
#+BEGIN_SRC scheme
(define (reverse l)
  (if (null? l)
      l
      (append (reverse (cdr l)) (list (car l)))))
#+END_SRC
***** 2.19
#+BEGIN_SRC scheme
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))

(define first-denomination car)
(define except-first-denomination cdr)
(define no-more? null?)

(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))

(cc 100 us-coins)
#+END_SRC
***** 2.20
#+BEGIN_SRC scheme
(define (same-parity i . j)
  (define (iter-list l)
    (cond ((null? l) l)
          ((= (remainder i 2) (remainder (car l) 2))
           (cons (car l) (iter-list (cdr l))))
          (else (iter-list (cdr l)))))
  (iter-list j))

(same-parity 1 2 3 4 5 6 7 8 9 10)
(same-parity 2 3 4 5 6 7 8 9 10 11)
#+END_SRC
*** Mapping over lists
- ~map~ defined as a higher-order procedure (Scheme comes with a more general ~map~ procedure built-in)
#+BEGIN_SRC scheme
(define (map proc items)
  (if (null? items)
      items
      (cons (proc (car items))
            (map proc (cdr items)))))
#+END_SRC
- ~map~ helps establish an abstraction barrier that isolates the implementation of procedures that transform lists from the details of how the elements of the list are extracted and combined.
**** Exercises
***** 2.21
#+BEGIN_SRC scheme
(define (square x) (* x x))
(define nil ())
(define (square-list-one items)
  (if (null? items)
      nil
      (cons (square (car items))
            (square-list (cdr items)))))

(define (square-list-two items)
  (map square items))

(square-list-one (list 1 2 3 4))
(square-list-two (list 1 2 3 4))
#+END_SRC
***** 2.22
The reason both procedures are producing lists in reverse order is because they each first iterate to the null case of the ~things~ list before starting to build up their answer list. To fix the problem you would need to swap the order of the arguments passed to ~iter~ so that ~answer~ is passed first and ~cons~-ed to the list with the result of iteration on the rest of ~things~. With this structure the list would be cons'd as the process iterates.
***** 2.23
#+BEGIN_SRC scheme
(define (my-for-each proc items)
  (cond ((null? items) #t)
        (else
         (proc (car items))
         (my-for-each proc (cdr items)))))

(my-for-each (lambda (x) (newline) (display x))
             (list 57 321 88))
#+END_SRC
*** 2.2.2 Hierarchical Structures
- Another way to thihnik of sequences whose elements are sequehnces is as /trees/. The elements of the sequence are branches of the tree, and elements that are themselves sequences are subtrees.
**** Exercises
***** 2.24
Skipped
***** 2.25
#+BEGIN_SRC scheme
(car (cdr (car (cdr (cdr '(1 3 (5 7) 9))))))
(car (car '((7))))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr
                                                    '(1 (2 (3 (4 (5 (6 7))))))
                                                    ))))))))))))
#+END_SRC
***** 2.26
#+BEGIN_SRC scheme
(define x (list 1 2 3))
(define y (list 4 5 6))

(append x y)
; (1 2 3 4 5 6)
(cons x y)
; ((1 2 3) 4 5 6)
(list x y)
; ((1 2 3) (4 5 6))
#+END_SRC
***** 2.27
#+BEGIN_SRC scheme
(define (deep-reverse items)
  (cond ((null? items) items)
        ((pair? (car items))
         (append (deep-reverse (cdr items)) (list (deep-reverse (car items)))))
        (else
         (append (deep-reverse (cdr items)) (list (car items))))))

(define x (list (list 1 2) (list 3 4)))

(deep-reverse x)
(deep-reverse '( 1 2 3 4 5))
#+END_SRC
***** 2.28
#+BEGIN_SRC scheme
(define (fringe items)
  (cond ((null? items) items)
        ((pair? items)
         (append (fringe (car items)) (fringe (cdr items))))
        (else (list items))))

(define x (list (list 1 2) (list 3 4)))
(fringe x)
(fringe (list x x))
#+END_SRC
Given
#+BEGIN_SRC scheme
(define (make-mobile left right)
  (list left right))
; structure is either a number (for a weight) or another mobile
(define (make-branch length structure)
  (list length structure))
#+END_SRC
a.
#+BEGIN_SRC scheme
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (car (cdr mobile)))

(define m (make-mobile 1 2))
(left-branch m)
(right-branch m)
#+END_SRC
b.
#+BEGIN_SRC scheme
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (car (cdr branch)))
(define (total-weight structure)
  (cond ((not (pair? structure))
         structure)
        (else (+ (total-weight (branch-structure (left-branch structure)))
                 (total-weight (branch-structure (right-branch structure)))))))

(define m (make-mobile (make-branch 1 2)
                       (make-branch 3 4)))
(define large-m (make-mobile (make-branch 1 m)
                             (make-branch 2 m)))
(define larger-m (make-mobile (make-branch 1 m)
                              (make-branch 2 large-m)))
(total-weight m)
(total-weight large-m)
(total-weight larger-m)
#+END_SRC
c.
#+BEGIN_SRC scheme
(define (branch-torque branch)
  (* (branch-length branch)
     (total-weight (branch-structure branch))))
(define (balanced? structure)
  (cond ((not (pair? structure))
         #t)
        ((= (branch-torque (left-branch structure)) (branch-torque (right-branch structure)))
         (and (balanced? (branch-structure (left-branch structure)))
              (balanced? (branch-structure (right-branch structure)))))
        (else
         #f)))

(define b (make-mobile (make-branch 3 4)
                        (make-branch 2 6)))
(define db (make-mobile (make-branch 3 b)
                        (make-branch 2 b)))
(balanced? b)
(balanced? db)
#+END_SRC
d.
If we change the representation of mobiles to use ~cons~ instead of using ~list~ the programs will need to change the selectors of the branch and mobile structures to remove an extra ~car~ call that is necessary to extract the last value from a list structure. Other than that the program should be able to function without modification to other procedures.
***** 2.30
#+BEGIN_SRC scheme
(define (square-tree tree)
  (cond ((null? tree) tree)
        ((not (pair? tree)) (square tree))
        (else (cons (square-tree (car tree))
                    (square-tree (cdr tree))))))

(define (square-tree tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (square-tree sub-tree)
             (square sub-tree)))
       tree))

(define t (list 1
                (list 2 (list 3 4) 5)
                (list 6 7)))
(square-tree t)
#+END_SRC
***** 2.31
#+BEGIN_SRC scheme
(define (tree-map tree transform)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (tree-map sub-tree transform)
             (transform sub-tree)))
       tree))

(define (square-tree tree) (tree-map tree square))
#+END_SRC
***** 2.32
#+BEGIN_SRC scheme
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x) (cons (car s) x)) rest)))))
#+END_SRC
Answer referenced from https://billthelizard.blogspot.com/2011/03/sicp-232-generating-power-sets.html
*** 2.2.3 Sequences as Conventional Interfaces
- Sequences serve as a conventional interface that permits us to combine processing modules.
  - When we uniformly represent structures as sequences we localize the data structure dependencies in our programs to a small number of sequence operations.
**** Exercises
~accumulate~ procedure for reference:
#+BEGIN_SRC scheme
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
#+END_SRC
***** 2.33
#+BEGIN_SRC scheme
(define (acc-map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) nil sequence))

(acc-map (lambda (x) (+ 2 x)) '(1 2 3 4 5 6 7 8 9))
#+END_SRC
#+BEGIN_SRC scheme
(define (acc-append seq1 seq2)
  (accumulate cons seq2 seq1))

(acc-append '(1 2 3) '(4 5 6))
#+END_SRC
#+BEGIN_SRC scheme
(define (acc-length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))

(acc-length '(1 2 3 4 5 6 7 8 9 10))
#+END_SRC
***** 2.34
#+BEGIN_SRC scheme
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
                (+ (* x higher-terms) this-coeff))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 3 0 5 0 1))
; Value 79
#+END_SRC
***** 2.35
Original ~count-leaves~ procedure
#+BEGIN_SRC scheme
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))

(define my-tree (list 1 (list 2
                              (list 3 4))
                      (list 5 6)))
(count-leaves my-tree)
; Value 6
#+END_SRC
Redefined ~count-leaves~ as an accumulation
#+BEGIN_SRC scheme
(define (acc-count-leaves t)
  (accumulate + 0 (map (lambda (x)
                         (if (pair? x)
                             (acc-count-leaves x)
                             1))
                       t)))
(acc-count-leaves my-tree)
; Value 6
#+END_SRC
***** 2.36
#+BEGIN_SRC scheme
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      '()
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

(define s (list '(1 2 3) '(4 5 6) '(7 8 9) '(10 11 12)))
(accumulate-n + 0 s)
#+END_SRC
***** 2.37
#+BEGIN_SRC scheme
(define (dot-product v w)
  (accumulate + 0 (map * v w)))

(define (matrix-*-vector m v)
  (map (lambda (row) (dot-product v row)) m))

(define (transpose mat)
  (accumulate-n cons '() mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (row) (matrix-*-vector cols row)) m)))
#+END_SRC
***** 2.38
#+BEGIN_SRC scheme
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))

(define fold-right accumulate)
#+END_SRC
A property that the ~op~ should satisfy to guarantee ~fold-right~ and ~fold-left~ produce the same results is the commutative property, such as that satisfied by ~+~ and ~*~ operations.
***** 2.39
#+BEGIN_SRC scheme
(define (reverse-right sequence)
  (fold-right (lambda (x y)
                (append y (list x)))
              '() sequence))

(define (reverse-left sequence)
  (fold-left (lambda (x y)
               (append (list y) x))
             '() sequence))

(define s (list 1 2 3 4 5))
(reverse-left s)
(reverse-right s)
#+END_SRC
**** Nested Mappings
- Mapping and accumulating with ~append~ is very common so we can abstract it into a procedure ~flatmap~
#+BEGIN_SRC scheme
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
#+END_SRC
**** Exercises
***** 2.40
Reference procedures from the section
#+BEGIN_SRC scheme
(define (flatmap proc seq)
  (display proc) (display " ") (display seq)
  (accumulate append '() (map proc seq)))

;; prime? procedures from chapter 1
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

(define (prime? n)
  (fast-prime? n 5))

(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))

(prime-sum? '(2 1))

(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)))))

;; Solution

(define (unique-pairs n)
  (flatmap (lambda (i)
             (map (lambda (j) (list i j))
                  (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))

(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum? (unique-pairs n))))
#+END_SRC
***** 2.41
#+BEGIN_SRC scheme
(define (unique-triples n)
  (flatmap (lambda (i)
             (map (lambda (x) (cons i x))
                  (flatmap (lambda (j)
                             (map (lambda (k)
                                    (list j k))
                                  (enumerate-interval 1 (- j 1))))
                           (enumerate-interval 1 (- i 1)))))
           (enumerate-interval 1 n)))

(define (make-triple-sum t)
  (+ (car t) (cadr t) (caddr t)))

(define (triples-sum s n)
  (filter (lambda (t)
            (= (make-triple-sum t) s))
          (unique-triples n)))

(triples-sum 8 6)
(triples-sum 7 6)
(triples-sum 11 6)
(triples-sum 10 6)
#+END_SRC
***** 2.42
#+BEGIN_SRC scheme
(define (adjoin-position row col positions)
  (cons (make-position row col) positions))
(define empty-board '())

(define (make-position r c)
  (cons r c))
(define (row p)
  (car p))
(define (col p)
  (cdr p))

(define (on-diagonal? cp pos)
  (= (abs (- (row cp) (row pos)))
     (abs (- (col cp) (col pos)))))

(define (safe2? c positions)
  (let ((kth-queen (car positions))
        (rest-queens (filter (lambda (pos)
                               (not (= c (col pos))))
                             positions)))
    (define (iter q board)
      (or (null? board)
          (and (not (= (row kth-queen) (row (car board))))
               (not (on-diagonal? kth-queen (car board)))
               (iter q (cdr board)))))
    (iter kth-queen rest-queens)))

(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe2? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))

(length (queens 8))
;; 92
#+END_SRC

A lot of guidance from https://billthelizard.blogspot.com/2011/06/sicp-242-243-n-queens-problem.html
***** 2.43
The program runs so slowly because it is evaluating every possible layout of the board to determine which is valid. Interchanging the order of the nested mappings results in building a complete board and checking it for each row, rather than building the board up a row at a time (transforming the process from a linear recursive problem to a tree recursive problem and tree-recursive processes grow exponentially). The execution time of the solution, if the program in 2.42 executes in /T/ will be /T^n/
*** 2.2.4 Example: A Picture Language
- It is important to describe a language by focusing on the language's primitives, its means of combination and its means of abstraction.
**** Exercises
***** 2.44
#+BEGIN_SRC scheme
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))
#+END_SRC
***** 2.45
#+BEGIN_SRC scheme
(define (split first second)
  (lambda (painter)
    (second painter (first painter painter))))

(define right-split-2 (split below beside))
(define up-split-2 (split beside below))
#+END_SRC
***** 2.46
#+BEGIN_SRC scheme
(define (my-make-vect x y)
  (cons x y))
(define (xcor-vect v) (car v))
(define (ycor-vect v) (cdr v))

(define (add-vect v1 v2)
  (make-vect (+ (xcor-vect v1)
                (xcor-vect v2))
             (+ (ycor-vect v1)
                (ycor-vect v2))))

(define (sub-vect v1 v2)
  (make-vect (- (xcor-vect v1)
                (xcor-vect v2))
             (- (ycor-vect v1)
                (ycor-vect v2))))

(define (scale-vect s v)
  (make-vect (* s (xcor-vect v))
             (* s (ycor-vect v))))
#+END_SRC
***** 2.47
#+BEGIN_SRC scheme
;; a
(define (make-frame-a origin edge1 edge2)
  (list origin edge1 edge2))

(define (origin-frame-a frame)
  (car frame))
(define (edge1-frame-a frame)
  (cadr frame))
(define (edge2-frame-a frame)
  (caddr frame))

(define test-a (make-frame-a 1 2 3))
(origin-frame-a test-a)
(edge1-frame-a test-a)
(edge2-frame-a test-a)

;; b
(define (make-frame-b origin edge1 edge2)
  (cons origin (cons edge1 edge2)))

(define (origin-frame-b frame)
  (car frame))
(define (edge1-frame-b frame)
  (cadr frame))
(define (edge2-frame-b frame)
  (cddr frame))

(define test-b (make-frame-b 1 2 3))
(origin-frame-b test-b)
(edge1-frame-b test-b)
(edge2-frame-b test-b)
#+END_SRC
***** 2.48
#+BEGIN_SRC scheme
(define (make-segment-2 sv ev)
  (cons sv ev))
(define (start-segment-2 segment)
  (car segment))
(define (end-segment-2 segment)
  (cdr segment))
#+END_SRC
***** 2.49
a.
#+BEGIN_SRC scheme
(define outline-painter
  (lambda (frame)
    (segments->painter (list (make-segment (frame-origin frame) (frame-edge1 frame))
                             (make-segment (frame-origin frame) (frame-edge2 frame))
                             (make-segment (frame-edge2 frame) (vector-add (frame-edge1 frame) (frame-edge2 frame)))
                             (make-segment (frame-edge1 frame) (vector-add (frame-edge2 frame) (frame-edge1 frame)))))))

(define test-frame (make-frame (make-vect 0 0)
                               (make-vect 0.99 0)
                               (make-vect 0 0.99)))
(paint (outline-painter test-frame))
#+END_SRC
b.
#+BEGIN_SRC scheme
(define x-painter
  (lambda (frame)
    (segments->painter (list (make-segment (frame-origin frame) (vector-add (frame-edge1 frame) (frame-edge2 frame)))
                             (make-segment (frame-edge1 frame) (frame-edge2 frame))))))

(paint (x-painter test-frame))
#+END_SRC
c.
#+BEGIN_SRC scheme
(define diamond-painter
  (lambda (frame)
    (segments->painter (list (make-segment (vector-scale 0.5 (frame-edge1 frame)) (vector-scale 0.5 (frame-edge2 frame)))
                             (make-segment (vector-scale 0.5 (frame-edge1 frame)) (vector-add (make-vect 1 0) (vector-scale 0.5 (frame-edge2 frame))))
                             (make-segment (vector-add (make-vect 1 0) (vector-scale 0.5 (frame-edge2 frame))) (vector-add (make-vect 0 1) (vector-scale 0.5 (frame-edge1 frame))))
                             (make-segment (vector-add (make-vect 0 1) (vector-scale 0.5 (frame-edge1 frame))) (vector-scale 0.5 (frame-edge2 frame)))
                             ))))

(paint (diamond-painter test-frame))
#+END_SRC
d.
Skipped
***** 2.50
#+BEGIN_SRC scheme
(define (my-flip-horiz painter)
  (my-transform-painter painter
                        (make-vect 1.0 0.0)
                        (make-vect 0.0 0.0)
                        (make-vect 1.0 1.0)))
#+END_SRC
Skipped other transforms
***** 2.51
Skipped
***** 2.52
Skipped
**** Levels of language for robust design
- /stratified design/ is the notino that a complex system should be structured as a sequence of levels that are described using a sequence of languages.
  - Each level is constructed by combining parts that are regarded as primitive at that level, and the parts constructed at each level are used as primitives at the next level.
  - The language used at each level of a stratified design has primitives, means of combination, and means of abstraction appropriate to that level of detail.
  - Stratified design helps make programs robust, making it likely that small changes in a specification will require correspondingly small changes in the program.
** 2.3 Symbolic Data
*** 2.3.1 Quotation
**** Exercises
***** 2.53
#+BEGIN_SRC scheme
(list 'a 'b 'c)
; (a b c)
(list (list 'george))
; ((george))
(cdr '((x1 x2) (y1 y2)))
; ((y1 y2))
(cadr '((x1 x2) (y1 y2)))
; (y1 y2)
(pair? (car '(a short list)))
; #f
(memq 'red '((red shoes) (blue socks)))
; #f
(memq 'red '(red shoes blue socks))
; (red shoes blue socks)
#+END_SRC
***** 2.54
#+BEGIN_SRC scheme
(define (my-equal? a b)
  (cond ((and (null? a) (null? b))
         #t)
        ((or (null? a) (null? b))
         #f)
        ((and (pair? a) (pair? b))
         (and (eq? (car a) (car b))
              (my-equal? (cdr a) (cdr b))))
        (else (eq? a b))))

(my-equal? '(this is a list) '(this is a list))
(my-equal? '(this is a list) '(this (is a) list))
(my-equal? 1 1)
(my-equal? 2 1)
(my-equal? '(a b) '(a c))
(my-equal? '(a b) '(a b))
#+END_SRC
***** 2.55
The ~'~ symbol is syntactic sugar for calling the procedure ~quote~ on an object. Thus ~'(a b)~ is really evaluated as ~(quote (a b))~ and we can see they are the same with ~(equal? '(a b) (quote (a b)))~. So the second ~'~ in ~''abracadabra~ turns the expression into a quoted structure of ~(quote abracadabra)~, and calling ~car~ on it results in returning the first obect of the list ~(quote abracadabra)~. So ~(car ''abracadabra)~ returns ~quote~.
*** 2.3.2 Example: Symbolic Differentiation
Expression of differentiation rules:
#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        (else
         (error "unknown expression type -- DERIVE" exp))))
#+END_SRC

Selectors and constructors for ~deriv~ procedure
#+BEGIN_SRC scheme
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-product m1 m2) (list '* m1 m2))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p) (caddr p))
#+END_SRC

To simplify the result of the ~deriv~ procedure we just modify the constructors ~make-sum~ and ~make-product~ to enforce rules of simplifying the expressions
#+BEGIN_SRC scheme
(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
#+END_SRC
**** Exercises
***** 2.56
#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentiation? exp)
         (make-product (make-exponentiation (make-product (exponent exp) (base exp)) (- (exponent exp) 1))
                       (deriv (base exp) var)))
        (else
         (error "unknown expression type -- DERIVE" exp))))
(define (exponentiation? exp)
  (and (pair? exp) (eq? (car exp) '**)))
(define (base x) (cadr x))
(define (exponent x) (caddr x))
(define (make-exponentiation base expt)
  (cond ((=number? expt 0) 1)
        ((=number? expt 1) base)
        (else (list '** base expt))))

(deriv '(** x 2) 'x)
(deriv '(** x 3) 'x)
#+END_SRC
***** 2.57
Extending ~deriv~ to handle arbitrary number of arguments to sum and product expressions requires modifying the ~augend~ and ~multiplicand~ procedures.
#+BEGIN_SRC scheme
(define (augend x)
  (if (null? (cdddr x))
      (caddr x)
      (cons '+ (cddr x))))
(define (multiplicand x)
  (if (null? (cdddr x))
      (caddr x)
      (cons '* (cddr x))))
#+END_SRC
***** 2.58
****** a
#+BEGIN_SRC scheme
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list a1 '+ a2))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list m1 '* m2))))

(define (addend s) (car s))
(define (augend s) (caddr s))
(define (multiplier p) (car p))
(define (multiplicand p) (caddr p))
(define (sum? x)
  (and (pair? x) (eq? (cadr x) '+)))
(define (product? x)
  (and (pair? x) (eq? (cadr x) '*)))

(deriv '(x * y) 'x)
(deriv '(x + (3 * (x + (y + 2)))) 'x)
#+END_SRC
****** b
Skipped
*** 2.3.3 Example: Representing Sets
- Informally, a set is simply a collection of distinct objects.
**** Sets as unordered lists
- One way to represent a set is as a list in which no element appears more than once
- This implementation of sets is very inefficient. Each operation uses the ~element-of-set?~ procedure which potentially results in scanning every element of the set every time it is invoked.
- Set procedures
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
#+END_SRC
***** Exercises
****** 2.59
#+BEGIN_SRC scheme
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        ((not (element-of-set? (car set1) set2))
         (cons (car set1)
               (union-set (cdr set1) set2)))
        (else (union-set (cdr set1) set2))))

(union-set '(1 2 3 4) '(3 4 5 6))
#+END_SRC
****** 2.60
The effieciency of the procedures are similar to the representation of sets as lists containing only unique items. There is still the potential for scanning every item with a call to ~element-of-set?~, although the procedures to add an element to a set and take the union of two sets are faster because they do not need to be concerned with checking if the element is already present in the set and can just write the element in.

An application of this implementation of sets would be in a write-heavy use-case where you care more about adding items to a set and only occassionally performing read operations of the set or intersections with other sets and are also not concerned with the additional memory overhead of storing the duplicates. This implementation of sets is more efficient for writes than the previous implementation.
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set) (cons x set))

(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))

(define (union-set set1 set2)
  (append set1 set2))
#+END_SRC
**** Sets as ordered lists
- Set operations
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) false)
        (else (element-of-set? x (cdr set)))))

(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1
                     (intersection-set (cdr set1)
                                       (cdr set2))))
              ((< x1 x2)
               (intersection-set (cdr set1) set2))
              ((> x1 x2)
               (intersection-set set1 (cdr set2)))))))
#+END_SRC
***** Exercises
****** 2.61
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (cond ((element-of-set? x set)
         set)
        ((null? set) (cons x '()))
        ((< x (car set))
         (cons x set))
        ((> x (car set))
         (cons (car set) (adjoin-set x (cdr set))))))

(adjoin-set 4 '(1 3 5 7))
(adjoin-set 1 '(3 5 7))
(adjoin-set 7 '(1 3 5))
(adjoin-set 3 '(1 3 5 7))
(adjoin-set 2 '())
#+END_SRC
****** 2.62
#+BEGIN_SRC scheme
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        (else
         (let ((x1 (car set1)) (x2 (car set2)))
           (cond ((= x1 x2) (cons x1 (union-set (cdr set1) (cdr set2))))
                 ((< x1 x2) (cons x1 (union-set (cdr set1) set2)))
                 ((> x1 x2) (cons x2 (union-set set1 (cdr set2)))))))))

(union-set '(1 3 5 7) '(2 4 6 8))
(union-set '(1 2 3) '(4))
(union-set '(1 2) '(3 4))
(union-set '(1) '())
#+END_SRC
**** Sets as binary trees
***** Exercises
****** 2.63
Help on this question from https://billthelizard.blogspot.com/2013/03/sicp-263-265-sets-as-binary-trees.html
******* a
The two procedures will produce the same result, an ordered list of items
******* b
The two procedures have different orders of growth in the number of steps required to convert a tree to a list. The first procedure uses ~append~ at each step in the tree which results in more iterations over the list of elements to construct the final list, whereas the second procedure uses ~cons~ which is assumed to be a constant time operation to join elements of a list. Thus the second procedure will have a slower growth in the number of operations to convert a tree to a list.
****** 2.64
Skipped
****** 2.65
Skipped
****** 2.66
#+BEGIN_SRC scheme
(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) false)
        (else
         (let ((cur-key (key (entry set-of-records))))
           (cond ((= given-key cur-key)
                  (entry set-of-records))
                 ((< given-key cur-key)
                  (lookup given-key (left-branch set-of-records)))
                 ((> given-key cur-key)
                  (lookup given-key (right-branch set-of-records))))))))
#+END_SRC
*** 2.3.4 Example: Huffman Encoding Trees
- /Fixed length codes/ represent each symbol in a message with the same number of bits
- /Variable length codes/ can represent different symbols each with a different number of bits
**** Tree representation
#+BEGIN_SRC scheme
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))

(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-left tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
#+END_SRC
**** Decoding procedure
#+BEGIN_SRC scheme
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit -- CHOOSE-BRANCH " bit))))
#+END_SRC
**** Exercises
***** 2.67
#+BEGIN_SRC scheme
(define sample-tree
  (make-code-tree (make-leaf 'A 6)
                  (make-code-tree (make-code-tree (make-leaf 'B 3)
                                                  (make-code-tree (make-leaf 'C 1)
                                                                  (make-leaf 'D 1)))
                                  (make-code-tree (make-code-tree (make-leaf 'E 1)
                                                                  (make-leaf 'F 1))
                                                  (make-leaf 'null 0)))))

(define deadbeef '(1 0 1 1 1 1 0 0 0 1 0 1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 1))
(define facade '(1 1 0 1 0 1 0 1 0 0 1 0 1 1 1 1 0 0))
(define decade '(1 0 1 1 1 1 0 0 1 0 1 0 0 1 0 1 1 1 1 0 0))
(decode deadbeef sample-tree)
(decode facade sample-tree)
(decode decade sample-tree)
#+END_SRC
***** 2.68
#+BEGIN_SRC scheme
(define (encode-symbol symbol tree)
  (cond ((leaf? tree)
         '())
        ((element-in-set? symbol (symbols (left-branch tree)))
         (append (list 0)
                 (encode-symbol symbol (left-branch tree))))
        ((element-in-set? symbol (symbols (right-branch tree)))
         (append (list 1)
                 (encode-symbol symbol (right-branch tree))))
        (else (error "symbol not in tree -- ENCODE-SYMBOL " symbol))))

(encode '(D E C A D E) sample-tree)
; '(1 0 1 1 1 1 0 0 1 0 1 0 0 1 0 1 1 1 1 0 0)
#+END_SRC
***** 2.69
Given ~adjoin-set~ and ~make-leaf-set~
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))

(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)    ; symbol
                               (cadr pair))  ; frequency
                    (make-leaf-set (cdr pairs))))))
#+END_SRC
#+BEGIN_SRC scheme
(define sample-pairs '((A 5) (B 3) (C 1) (D 1) (E 1) (F 1)))

(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

(define (successive-merge leaf-set)
  (cond ((null? leaf-set) '())
        ((null? (cdr leaf-set)) (car leaf-set))
        (else
         (successive-merge
          (adjoin-set (make-code-tree (car leaf-set) (cadr leaf-set))
                      (cddr leaf-set))))))

(define huff-tree (generate-huffman-tree sample-pairs))
(decode (encode '(F A C A D E) huff-tree) huff-tree)
#+END_SRC
***** 2.70
#+BEGIN_SRC scheme
(define song-pairs '((a 2) (boom 1) (get 2) (job 2) (na 16) (sha 3) (yip 9) (wah 1)))
(define song-tree (generate-huffman-tree song-pairs))
(define song-message '(get a job
                           sha na na na na na na na na
                           get a job
                           sha na na na na na na na na
                           wah yip yip yip yip yip yip yip yip yip
                           sha boom))
(length (encode song-message song-tree))
; 84
#+END_SRC
84 bits are required for the encoding of the song.

If we were using a fixed length code to encode the song we would need to represent 8 different words which would require 3 bits per word (2^3 = 8 or log_2 8 = 3) and it would take 108 bits to encode.
***** 2.71
Skipped
***** 2.72
Skipped
** 2.4 Multiple Representations for Abstract Data
- Data-abstraction barriers are powerful tools for controlling complexity. By isolating the underlying representations of data objects, we can divide the task of designing a large program into smaller tasks that can be performed separately.
- In addition to data-abstraction barriers that isolate representation from use, we need abstraction barriers that isolate different design choices from each other and permit different choices to coexist in a single program.
- /Generic procedures/ - procedures that can operate on data that may be represented in more than one way.
*** 2.4.1 Representations for Complex Numbers
#+BEGIN_SRC scheme
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                        (+ (imag-part z1) (imag-part z2))))
(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))
(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))
(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))
#+END_SRC
*** 2.4.2 Tagged data
- Data abstraction can be viewed as an application of the "principle of least commitment.
  - The abstraction barrier formed by the selectors and constructors permits us to defer to the last possible moment the choice of which concrete representation of data objects to use. This waiting to choose to the last possible moment allows us to retain maximum flexibility in our system design
  - We can carry this principle further by maintaining ambiguity of representation even after the selectors and constructors are designed and use both representations in a system, so long as we have a way to distinguish what form the data is in (type tags)
**** Type tagging data
#+BEGIN_SRC scheme
(define (attach-tag type-tag contents)
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum -- TYPE-TAG" datum)))
(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum -- CONTENTS" datum)))

(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))
(define (polar? z)
  (eq? (type-tag z) 'polar))

;; complex number representation rectangular (real, imaginary)
(define (real-part-rectangular z) (car z))
(define (imag-part-rectangular z (cdr z)))
(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
           (square (imag-part-rectangular z)))))
(define (angle-rectangular z)
  (atan (imag-part-rectangular z)
        (real-part-rectangular z)))
(define (make-from-real-image-rectangular x y)
  (attach-tag 'rectangular (cons x y)))
(define (make-from-mag-ang-rectangular r a)
  (attach-tag 'rectangular
              (cons (* r (cos a)) (* r (sin a)))))

;; complex number representation polar (magnitude, angle)
(define (real-part-polar z)
  (* (magnitude-polar z) (cos (angle-polar z))))
(define (imag-part-polar z)
  (* (magnitude-polar z) (sin (angle-polar z))))
(define (magnitude-polar z) (car z))
(define (angle-polar z) (cdr z))
(define (make-from-real-imag-polar x y)
  (attach-tag 'polar
              (cons (sqrt (+ (square x) (square y)))
                    (atan y x))))
(define (make-from-mag-ang-polar r a)
  (attach-tag 'polar (cons r a)))

;; Generic selectors

(define (real-part z)
  (cond ((rectangular? z)
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else (error "Unknown type -- REAL-PART" z))))
(define (imag-part z)
  (cond ((rectangular? z)
         (imag-part-rectangular (contents z)))
        ((polar? z)
         (imag-part-polar (contents z)))
        (else (error "Unknown type -- IMAG-PART" z))))
(define (magnitude z)
  (cond ((rectangular? z)
         (magnitude-rectangular (contents z)))
        ((polar? z)
         (magnitude-polar (contents z)))
        (else (error "Unknow type -- MAGNITUDE" z))))
(define (angle z)
  (cond ((rectangular? z)
         (angle-rectangular (contents z)))
        ((polar? z)
         (angle-polar (contents z)))
        (else (error "Unknow type -- ANGLE" z))))

;; Constuctors
(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))
(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))
#+END_SRC
- The arithmetic operations from 2.4.1 remain the same because they call the generic selectors
- Since each data object above is tagged with its type, the selectors operate on the data in a generic manner. Each selector has behavior defined that depends on the particular type of data its is applied to.
*** 2.4.3 Data-Directed Programming and Additivity
- The general strategy of checking the type of a datum and calling an appropriate procedure is called /dispatching on type/
  - This is a powerful strategy for achieving modularity in a system. However it does have some weaknesses
    1. Generic interface procedures must know about all the different representations
    2. Must guarantee no two procedures in the entire system have the same name
  - To address this problems we need a means for modularizing the system design even further
- /Data Directed Programming/
  - When dealing with a set of generic operations that are common to a set of different types we are in effect dealing with a two dimensional table that contains possible operations on one axis and possible types on the other axis, and entries the procedures that implement each operation for each type of argument presented.
  - Data directed programming is the technique of designing programs to work with such a table directly.
  - Can define a set of procedures, or /package/, and interace them to the rest of the system by adding entries to the table.
**** Exercises
***** 2.73
#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp)) (operands exp)
               var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
#+END_SRC
****** a
Above we, presumably, added an entry into the dispatch table for the procedure ~deriv~ under the type of the operator. For ~'+~ the entry would be ~(put 'deriv '+ 'make-sum)~. Thus we can remove the check of ~sum?~ or ~product?~ and instead ~get~ the proper function based on the operator type.
We could not achieve the same for ~number?~ and ~same-variable?~ because their arguments lack any type tags and already operate on a specific primitive type of number and symbol, respectively.
****** b
#+BEGIN_SRC scheme
(define (deriv-sum a1 a2)
  (make-sum (deriv a1 var)
            (deriv a2 var)))
(define (deriv-product m1 m2)
  (make-sum (make-product m1 (deriv m2 var))
            (make-product (deriv m1 var) m2)))

(put 'deriv '+ 'deriv-sum)
(put 'deriv '* 'deriv-product)
#+END_SRC
****** c
#+BEGIN_SRC scheme
(define (deriv-expt base expt)
  (make-product (make-exponentiation (make-product (exponent exp) (base exp)) (- (exponent exp) 1))
                (deriv (base exp) var)))

(put 'deriv '** 'deriv-expt)
#+END_SRC
****** d
If we indexed the procedures in the opposite way, ~((get (operator exp) 'deriv) (operands exp) var)~, the changes required to the derivative system would be minimal, it would only require updating the order of how the procedures are inputted and requested from the dispatch table. Instead of ~(put 'deriv '+ 'deriv-sum)~ it would be ~(put '+ 'deriv 'deriv-sum)~.
***** 2.74
Skipped, but the tl;dr would be for the company to create the necessary abstraction layers to allow the use of various employee representations to be queried in the same manner from the centralized querying system. To do this, each division should export a package that implements a common interface needed by the centralized system. The various division implementations of this interface should present the type of the data structure containing employee information (type tag) alongside their implementation of the higher level primitives of the central querying service. This way, any new division can implement their record keeping however they wish, as long as they provide a package that implements the common interface that can be loaded into a method dispatch table based on that division's type and the data can be queried using the type specific implementation. The centralized query system can then be built using generic functions that look up the actual interface implementation functions on type.
**** Message passing
- /Message passing/ is a style of programming where the data object is an entity that receives the requested operation name as a "message".
  - Procedure dispatch is done using operation names on "intelligent data objects".
***** Exercises
****** 2.75
#+BEGIN_SRC scheme
(define (make-from-mag-ang r a)
  (define (dispatch op)
    (cond ((eq? op 'real-part)
           (* r (cos a)))
          ((eq? op 'imag-part)
           (* r (sin a)))
          ((eq? op 'magnitude) r)
          ((eq? op 'angle) a)
          (else (error "Unknown op -- MAKE-FROM-MAG-ANG" op)))))
#+END_SRC
****** 2.76
Skipped
** 2.5 Systems with Generic Operations
*** 2.5.1 Generic Arithmetic Operations
- Defining a generic arithmetic package that can operate on normal, rational, and complex numbers
#+BEGIN_SRC scheme
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generik 'sub x y))
(define (mul x y) (apply-generic 'muln x y))
(define (div x y) (apply-generik 'div x y))


(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  'done)

(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))

  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))

  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
#+END_SRC
**** Exercises
***** 2.77
By adding the selectors to the complex package in the following way:
#+BEGIN_SRC scheme
...
(put 'magnitude '(complex) magnitude)
...
#+END_SRC
You associate the generic ~magnitude~ procedure with a complex number that returns the complex number package-level generic ~magnitude~ whose implementation may look something like:
#+BEGIN_SRC scheme
(define (magnitude z)
  (cond ((rectangular? z)
         (magnitude-rectangular (contents z)))
        ((polar? z)
         (magnitude-polar (contents z)))
        (else (error "Unknow type -- MAGNITUDE" z))))
#+END_SRC
When the method ~(magnitude z)~ dispatches from the generic aritmetic package the complex number ~magnitude~ procedure is returned and then that procedure is passed the number ~z~ and checks the specific complex representation type of ~z~ during execution, returning the proper computation of magnitude. It works through multiple levels of abstraction, three in this case: ~magnitude~ in the arithmetic package, ~magnitude~ in the complex number package, and finally ~magnitude-rectangular~ or ~magnitude-polar~ on the complex number type.
***** 2.78
#+BEGIN_SRC scheme
(define (attach-tag type-tag contents)
  (if (number? contents)
      contents
      (cons type-tag contents)))
(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (else  (error "Bad tagged datum -- TYPE-TAG" datum))))
(define (type-tag datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (else  (error "Bad tagged datum -- CONTENTS" datum))))
#+END_SRC
***** 2.79
#+BEGIN_SRC scheme
(define (equ? x y) (apply-generic 'equ? x y))

;; number package
(put 'equ? '(scheme-number scheme-number)
     (lambda (x y) (= x y)))

;; rational number package
(put 'equ? '(rational rational)
     (lambda (x y) (and (= (numer x) (numer y))
                        (= (denom x) (denom y)))))

;; complex number package
(put 'equ? '(complex complex)
     (lambda (z1 z2) (and (= (real-part x) (real-part y))
                          (= (imag-part x) (imag-part y)))))
#+END_SRC
***** 2.80
#+BEGIN_SRC scheme
(define (=zero? x) (apply-generic '=zero? x))

;; number package
(put '=zero? '(scheme-number)
     (lambda (x) (= 0 x)))

;; rational number package
(put '=zero? '(rational)
     (lambda (x) (and (= (numer x) 0)
                      (= (denom x) 0))))

;; complex number
(put '=zero? '(complex)
     (lambda (x) (and (= (real-part x) 0)
                      (= (imag-part x) 0))))
#+END_SRC
*** 2.5.2 Combining Data of Different Types
**** Coercion
- /Coercion/ is when objects of one type may be viewed as being of another type.
  - We can implement the idea of coercion by designing coercion procedures that transform an object of one type into an equivalent object of another type
#+BEGIN_SRC scheme
;; Coercion
(define (scheme-number->complex n)
  (make-complex-from-real-imag (contents n) 0))

;; place coercion methods into a coercion table
;; we assume a corresponding 'get-coercion' to retrieve the procedure
(put-coercion 'scheme-number 'complex scheme-number->complex)

;; apply-generic using coercion methods
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (else
                         (error "No method for these types" (list op type-tags))))))
              (error "No method for these types" (list op type-tags)))))))
#+END_SRC
**** Hierarchies of types
- With type hierarchies you do not need to explicitly define a coercion procedure for each type transformation, instead you can define how to transform a type into another type through transformations along the type hierarchy.
  - The example given is instead of a coercion procedure to transform an integer to a complex number, the type hierarchy transforms an integer to a rational number, a rational number to a real number, and finally a real number to a complex number.
**** Exercises
***** 2.81
****** a
If ~apply-generic~ is called with two ~scheme-number~ arguments for the ~exp~ then, since the procedure is defined for those types, ~apply-generic~ will find the procedure in the normal method table and apply it. If it is called with two ~complex~ number types for the ~exp~ procedure it will end up in an infinite loop of calling ~apply-generic~ after calling the type coercion method for ~complex->complex~.
****** b
The ~apply-generic~ procedure would work fine without the same type coercion methods. Being passed a procedure and arguments of the same type, the initial procedure ~get~ would either find the procedure to apply or would throw an error because no such procedure exists for the two supplied types
****** c
#+BEGIN_SRC scheme
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond ((eq? type1 type2) ;; this case should never be true because we would have found the procedure in the first 'get' call
                         (error "No method for these types" (list op type-tags)))
                        (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (else
                         (error "No method for these types" (list op type-tags))))))
              (error "No method for these types" (list op type-tags)))))))
#+END_SRC
***** 2.82
Untested
#+BEGIN_SRC scheme
;; This tries only to coerce all types to the first arg
(define (apply-generic op . args)
  (define (coerce base arg)
    (let ((type1 (type-tag base))
          (type2 (type-tag arg)))
      (let ((t1->t2 (get-coercion type1 type2)))
        (if t1->t2
            (t1->t2 arg)
            (error "No coercion method for these types" (list type1 type2))))))
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (let ((coerced-args (map (lambda (t2) (coerce (car args) t2)) (cdr args))))
            (let ((coerced-type-tags (map type-tags coerced-args)))
              (let ((coerced-proc (get op coerced-type-tags)))
                (if coerced-proc
                    (apply proc (map contents coerced-args))
                    (error "No method for these types" (list op coerced-type-tags))))))))))
#+END_SRC
***** 2.83
#+BEGIN_SRC scheme
(define (raise arg tower)
  (if (null? tower)
      arg
      (if (eq? (type-tag arg) (car tower))
          (let ((supertype (cadr tower)))
            (let ((proc (get-coercion (type-tag arg) supertype)))
              (proc (contents arg))))
          (raise arg (cdr tower)))))
#+END_SRC
***** 2.84
#+BEGIN_SRC scheme
(define (lower? arg1 arg2 tower)
  (let ((type1 (type-tag arg1))
        (type2 (type-tag arg2)))
    (if (not (null? tower))
        (cond ((eq? type1 (car tower))
               true)
              ((eq? type2 (car tower))
               false)
              (else (lower arg1 arg2 (cdr tower))))
        (else (error "Types not in tower" (list type1 type2))))))


(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))
        (tower '(scheme-number rational real complex)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (cond ((lower? a1 a2 tower)
                       (apply-generic op (raise a1 tower) a2))
                      ((lower? a2 a1 tower)
                       (apply-generic op a1 (raise a2 tower)))
                      (else
                       (error "No method for these types" (list op type-tags))))))
              (error "No method for these types" (list op type-tags)))))))

#+END_SRC
***** 2.85
Skipped
***** 2.86
Skipped
*** 2.5.3 Example: Symbolic Algebra
- An algebraic expression, in general, can be viewed as a hierarchical structure, a tree of operators aplied to operands.
**** Exercises
***** 2.87
#+BEGIN_SRC scheme
(define (poly? term)
  (pair? term))

(put '=zero? '(polynomial)
     (lambda (coeff)
       (cond ((poly? coeff))
             ((number? coeff) (= 0 coeff))
             (else (error "Unknown type" coeff)))))
#+END_SRC
***** 2.88
#+BEGIN_SRC scheme
(define (negate p)
  (define (negate-terms terms)
    (if (empty-termlist? terms)
        the-empty-termlist
        (let ((first (first-term terms)))
          (cond ((poly? (coeff first))
                 (adjoin-term
                  (make-term (order first)
                             (negate (coeff first)))
                  (negate-terms (rest-terms terms))))
                (else
                 (adjoin-term
                  (make-term (order first)
                             (* -1 (coeff first)))
                  (negate-terms (rest-terms terms))))))))
  (make-poly (variable p) (negate-terms (term-list p))))

(define (sub-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (add-terms (term-list p1)
                            (term-list (negate p2))))
      (error "Polys not in the same var -- SUB-POLY" (list p1 p2))))
#+END_SRC
***** 2.89
Skipped
***** 2.90
Skipped
***** 2.91
Skipped
***** 2.92
Skipped
***** 2.93
Skipped
***** 2.94
Skipped
***** 2.95
Skipped
***** 2.96
Skipped
***** 2.97
Skipped
